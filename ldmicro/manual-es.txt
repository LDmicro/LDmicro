
INTRODUCCION
============

LDmicro genera código nativo para ciertos Microchip PIC16 y Atmel AVR
microcontroladores. Por lo general, el software para estos microcontroladores está escrito
en un lenguaje de programación como ensamblador, C o BASIC. Un programa en uno
de estos idiomas comprende una lista de declaraciones. Estos idiomas son
potente y bien adaptado a la arquitectura del procesador, que
ejecuta internamente una lista de instrucciones.

Los PLC, por otro lado, a menudo se programan en "lógica de escalera". (A) simple
El programa podría verse así:

   ||                                                                    ||
   ||    Xbutton1           Tdon           Rchatter           Yred       ||
 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||
   ||                                 |                                  ||
   ||    Xbutton2           Tdof      |                                  ||
   ||-------]/[---------[TOF 2.000 s]-+                                  ||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||    Rchatter            Ton             Tnew           Rchatter     ||
 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||------[END]---------------------------------------------------------||
   ||                                                                    ||
   ||                                                                    ||

(TON es un retraso de encendido; TOF es un retraso de apagado. --] [-- declaraciones
son entradas, que se comportan como los contactos en un relé. los
--( )-- las declaraciones son salidas, que se comportan como la bobina de un
relé. Muchas buenas referencias para la lógica de escalera están disponibles en Internet.
y en otros lugares; Los detalles específicos de esta implementación se dan a continuación.)

Un número de diferencias son evidentes:

    * El programa se presenta en formato gráfico, no como una lista de texto.
       de declaraciones. Muchas personas inicialmente encontrarán esto más fácil de
       entender.

    * En el nivel más básico, los programas parecen diagramas de circuito, con
       Contactos de relé (entradas) y bobinas (salidas). Esto es intuitivo para
       programadores con conocimientos de teoría de circuitos eléctricos.

    * El compilador de lógica de escalera se encarga de lo que se calcula
       dónde. No tiene que escribir código para determinar cuándo las salidas
       tienen que volver a calcular en función de un cambio en las entradas o un
       temporizador de eventos, y no tiene que especificar el orden en que
       estos cálculos deben llevarse a cabo; Las herramientas PLC lo hacen por usted.

LDmicro compila la lógica de escalera a código PIC16 o AVR. El seguimiento
Los procesadores son compatibles:
    * PIC16F877
    * PIC16F628
    * PIC16F876
    * PIC16F88
    * PIC16F819
    * PIC16F887
    * PIC16F886
    * PIC16F72
    * PIC12F675
    * PIC12F683
    * PIC16F1512
    * PIC16F1516
    * PIC16F1527
    * PIC10F202
    * PIC10F200
    * ATmega128
    * ATmega64
    * ATmega162
    * ATmega32
    * ATmega32U4
    * ATmega16
    * ATmega8
    * ESP8266
    * STM32
    * "Código PASCAL "para PC LPT y COM
    * y un montón de...

Sería fácil admitir más chips AVR o PIC16, pero no tengo
alguna forma de probarlos. Si necesita uno en particular, contácteme y
Veré que puedo hacer.

Con LDmicro, puede dibujar un diagrama de escalera para su programa. Usted puede
simule la lógica en tiempo real en su PC. Entonces cuando estés convencido
que es correcto, puede asignar pines en el microcontrolador al
programa entradas y salidas. Una vez que haya asignado los pines, puede
compila el código PIC o AVR para tu programa. La salida del compilador es un .hex
archivo que puede programar en su microcontrolador usando cualquier PIC / AVR
programador.

LDmicro está diseñado para ser algo similar a la mayoría de los PLC comerciales
Sistemas de programación. Hay algunas excepciones y muchas cosas.
de todos modos no son estándar en la industria. Lea atentamente la descripción
de cada instrucción, incluso si parece familiar. Este documento asume
Conocimientos básicos de la lógica de escalera y de la estructura del software PLC.
(el ciclo de ejecución: leer entradas, calcular, escribir salidas).

PLC y seguridad
    https://github.com/LDmicro/LDmicro/wiki/PLC-and-safety

Tiempo 0 de ciclo del PLC
    https://github.com/LDmicro/LDmicro/wiki/PLC-Cycle-Time-0

OBJETIVOS ADICIONALES
=====================

También es posible generar código ANSI C. Podrías usar esto con cualquier
procesador para el que tiene un compilador de C, pero usted es responsable de
suministrando el tiempo de ejecución. Eso significa que LDmicro solo genera fuente
para una función PlcCycle (). Usted es responsable de llamar a PlcCycle
cada ciclo, y usted es responsable de implementar todas las E / S
(lectura / escritura de entrada digital, etc.) funciones a las que llama PlcCycle (). Ver
los comentarios en la fuente generada para más detalles.

Finalmente, LDmicro puede generar bytecode independiente del procesador para un
Máquina virtual diseñada para ejecutar código de lógica de escalera. He proporcionado una
implementación de muestra del intérprete/VM, escrita en bastante portátil
C. Este objetivo funcionará para casi cualquier plataforma, siempre que
puede suministrar su propia VM. Esto puede ser útil para aplicaciones donde
desea utilizar la lógica de escalera como un 'lenguaje de script' para personalizar un
programa. Vea los comentarios en el intérprete de muestra para más detalles.

Se ha agregado un nuevo objetivo "Controllino Maxi / Ext bytecode". Genera
Archivo .xint interpretable por el software LDuino PLC. Hasta ahora solo
Controllino Maxi PLC es compatible. Sin embargo, como el código de bytes es genérico,
Se puede hacer la adaptación a cualquier otra placa de PLC o CPU. Ver código fuente LDuino
para eso.

OPCIONES DE LINEA DE COMANDO
============================

ldmicro.exe generalmente se ejecuta sin opciones de línea de comandos. Eso significa
que puede hacer un acceso directo al programa o guardarlo en su
escritorio y haga doble clic en el icono cuando desee ejecutarlo, y luego
puede hacer todo desde la GUI.

Si se pasa LDmicro un solo nombre de archivo en la línea de comando
(por ejemplo, `ldmicro.exe asd.ld '), LDmicro intentará abrir` asd.ld',
si existiera. Se produce un error si `asd.ld 'no existe. Esta
significa que puede asociar ldmicro.exe con archivos .ld, para que se ejecute
automáticamente cuando hace doble clic en un archivo .ld.

Si LDmicro se pasa argumentos de línea de comando en el formulario
`ldmicro.exe / c src.ld dest.hex ', luego intenta compilar` src.ld',
y guarde la salida como 'dest.hex'. LDmicro sale después de compilar,
si la compilación fue exitosa o no. Cualquier mensaje se imprime
a la consola Este modo es útil solo cuando se ejecuta LDmicro desde
línea de comando.


LO ESENCIAL
===========

Si ejecuta LDmicro sin argumentos, entonces comienza con el programa vacio.
Si ejecuta LDmicro con el nombre de un programa de escalera (xxx.ld)
en la línea de comando, entonces intentará cargar ese programa al inicio.
LDmicro usa su propio formato interno para el programa; no puede importar
lógica de cualquier otra herramienta.

Si no cargó un programa existente, se le dará un programa
con un peldaño vacío Podrías agregarle una instrucción; por ejemplo
puede agregar un conjunto de contactos (Instrucción -> Insertar contactos) llamado
'Xnuevo'. 'X' significa que los contactos estarán vinculados a un pin de entrada en el
microcontrolador Puede asignarle un pin más tarde, después de elegir un
microcontrolador y cambio de nombre de los contactos (Se tienen que cambiar los nombres es obligado).
La primera letra de un nombre indica qué tipo de objeto es. Por ejemplo:

    * Xname -- vinculado a un pin de entrada en el microcontrolador
    * Yname -- vinculado a un pin de salida en el microcontrolador
    * Rname -- `relé interno ': un bit en la memoria
    * Tname -- un temporizador retraso de encendido, retraso de apagado o retentivo
    * Cname -- un contador, ya sea cuenta adelante o cuenta atrás
    * Aname -- una lectura entera de un convertidor A / D
    * Pname -- vinculado a un pin de salida PWM en el microcontrolador
    * Mname -- vinculado a una salida de bobina MODBUS
    * Iname -- vinculado  a una entrada discreta MODBUS
    * Hname -- vinculado to a MODBUS Holding register
    * name  -- una variable de propósito general (entero)

   Nombre de la variable que comienza con el símbolo. '#' como
    #PORTA, #PORTB, #PORTC, ... tratado como puerto de hardware de salida.
     Nombre de la variable que comienza con el símbolo. '#' como
    #PINA, #PINB, #PINC, ... tratado como puerto de entrada de hardware.
    Nombre de la variable que comienza con el símbolo.'#' como
    #TRISA, #TRISB, #TRISC, ... tratado como registro de dirección de datos de los puertos correspondientes
    #PORTA, #PORTB, #PORTC, ...
    Nota: la dirección PORTn y PINn son iguales para PIC's

    El nombre de la variable que comienza con un carácter '#' y luego un número
     (comúnmente un hexadecimal) tratada como la dirección inmediata del registro de hardware.
     Un valor como # 0xXXXX es un direccionamiento inmediato, directo y explícito.
     Por ejemplo:
     # 0x8E tratado como la dirección del registro PCON de hardware
       del microcontrolador Microchip PIC16F628.
     # 0x136 tratado como la dirección del registro UDR3 de hardware
       (Registro de datos de E/S USART3) del microcontrolador Atmel ATmega2560.

    El nombre de la variable que comienza con un carácter '#' y posterior como
     un nombre de variable de propósito general tratado como la dirección indirecta del registro de hardware.
     Un valor como #VarName es la dirección indirecta del registro de hardware (puntero de dirección indirecta).
     Por ejemplo:
      {MOV  portAddr:=}    portAddr es una variable de propósito general que contiene el valor 0x05.
    --{           0x05}--

      {MOV #portAddr:=}    #portAddr tratada como la dirección indirecta del registro # 0x05 PORTA (Microchip PIC16F887).
    --{           0xF0}--  Los pines de salida PORTA se establecen en un valor binario de 11110000.

      {ADD  portAddr:=}    La variable portAddr de propósito general ahora tiene un valor de 0x06.
    --{portAddr  +   1}--

      {MOV #portAddr:=}    #portAddr tratada como la dirección indirecta del registro # 0x06 PORTB (Microchip PIC16F887).
    --{           0x0F}--  Los pines de salida PORTB están configurados en un valor binario de 00001111.
    * Wiki: LDmicro direccionamiento indirecto
      https://github.com/LDmicro/LDmicro/wiki/LDmicro-indirect-addressing

    Tenga cuidado al escribir en los registros de hardware mediante el acceso inmediato a la dirección.
     Vea cómo acceder a SPI a través de los registros de hardware.
    * Wiki: SPI: Interfaz Periférica Serial
      https://github.com/LDmicro/LDmicro/wiki/SPI:-Serial-Peripheral-Interface


Elija el resto del nombre para que describa lo que hace el objeto,
y para que sea único dentro del programa. El mismo nombre siempre se refiere
al mismo objeto dentro del programa. Por ejemplo, sería un error.
tener un retraso de encendido (TON) llamado 'Tdelay' y un retraso de apagado (TOF)
llamado 'Tdelay' en el mismo programa, ya que cada contador necesita su propio
memoria. Por otro lado, sería correcto tener un temporizador retentivo
(RTO) llamado `Tdelay 'y una instrucción de reinicio (RES) asociada con
'Tdelay', ya que en ese caso desea que ambas instrucciones funcionen
El mismo temporizador.

Los nombres de las variables pueden consistir en letras, números y guiones bajos '_'.
Un nombre de variable no debe comenzar con un número. Los nombres de las variables son
distingue mayúsculas y minúsculas.

Las instrucciones variables generales (MOV, ADD, EQU, etc.) pueden funcionar en
variables con cualquier nombre. Esto significa que pueden acceder al temporizador y
Contadores acumuladores. Esto a veces puede ser útil; Por ejemplo usted
podría verificar si la cuenta de un temporizador está en un rango particular.

Las variables son siempre enteros de 16 bits. Esto significa que pueden ir
de -32768 a 32767. Las variables siempre se tratan como firmadas.

ACTUALIZADO: Versión 4.3.0
Las variables pueden asignar 1,2,3 o 4 bytes. Puede cambiar el tamaño de la variable
haciendo doble clic en el nombre de la variable en la lista en la parte inferior de la pantalla.
Las variables se almacenan y procesan en forma de complemento de dos.
Ver https://en.wikipedia.org/wiki/Two%27s_complement

Bytes    Tipos      Intervalo de                  a
 1   signed int8   -2^7 =       -128=0x80        2^7 -1=       127=0x7f
 2   signed int16  -2^15=     -32768=0x8000      2^15-1=     32767=0x7fff
 3   signed int24  -2^23=   -8388608=0x800000    2^23-1=   8388607=0x7fFFFF
 4   signed int32  -2^31=-2147483648=0x80000000  2^31-1=2147483647=0x7fffFFFF

El valor cero decimal (0) se representa como todos los bits ceros 00 ... 000
El valor decimal (-1) representado como todos 11 ... 111

Las variables int8 firmadas se utilizan para hacer que el archivo hexadecimal sea más pequeño y más rápido.
Los tipos firmados int24 e int32 se utilizan para aumentar el rango de variables.
La extensión de signo para variables de diferentes tamaños se proporciona automáticamente.
Nota: Las instrucciones MUL, DIV, MOD no pueden procesar variables int32.

El indicador de desbordamiento aritmético (subflujo) se proporciona como relé interno ROverflowFlagV.
https://en.wikipedia.org/wiki/Overflow_flag
https://www.allaboutcircuits.com/textbook/digital/chpt-2/binary-overflow/
El indicador de desbordamiento indica que el resultado del complemento a dos firmado
No cabe en el número de bits utilizados para la operación, y señala un error.
Por ejemplo, si la variable int8 dest = 127 (0x7f) suma 1, obtenemos -128 (0x80),
y el indicador de desbordamiento ROverflowFlagV se establecerá en 1.
En cambio, si la variable int16 dest = 127 (0x007f) agrega 1, obtenemos 128 (0x0080),
y el indicador de desbordamiento ROverflowFlagV no se ve afectado.
LDmicro restablece el ROverflowFlagV a cero durante la inicialización.
Nota: CTC genera un impulso de sobrellenado (carry) cuando Counter == Max.
       El CTR genera un impulso de sobrellenado (prestado) cuando el Contador == Min.
       Overfill no establece la bandera de desbordamiento.

El indicador de superposición se proporciona como el estado de salida de las operaciones ADD, SUB.
El indicador de superposición indica que se ha cambiado el signo del resultado.
Por ejemplo, se produjo una superposición cuando -1 (0xf..f) agrega 1 (o sub -1), obtenemos 0 (0x0..0),
todos los 1 se cambian a todos ceros 0.
Además, se produjo una superposición cuando 0 (0x0..0) sub 1 (o agregar -1), obtenemos -1 (0xf..f),
todos los ceros 0 se cambian a todos unos 1.
Por ejemplo, se produjo una superposición cuando -10 agrega 15 (o sub -15), obtenemos 5,
fuente negativa se cambia a resultado positivo.
Además, se produjo una superposición cuando 10 sub 15 (o agregamos -15), obtenemos -5,
fuente positiva se cambia a resultado negativo.
ACTUALIZACIONES FINALES: Versión 4.3.0

Puede especificar literales como números decimales normales (10, 1234, -56).
También puede especificar valores de caracteres ASCII ('A', 'z') poniendo
El personaje entre comillas simples. Puedes usar un código de caracteres ASCII
en la mayoría de los lugares donde podrías usar un número decimal.
Puede usar números hexadecimales (0xA, 0x04D2, 0xffc8),
números octales (0o12, 0o2322, 0o177710),
números binarios (0b1010, 0b10011010010, 0b1111111111001000)
en la mayoría de los lugares donde podrías usar un número decimal.
LDmicro usó los prefijos C:
0x__ o 0X__ para números hexadecimales con dígitos 1234567890ABCDEF
0o__ o 0O__ o 0__ números octales con 01234567 dígitos
0b__ o 0B__ para números binarios con 01 dígitos.
Hexadecimales, la notación binaria es más cómoda para opacidades bit a bit.

En la parte inferior de la pantalla, verá una lista de todos los objetos en
el programa. Esta lista se genera automáticamente desde el programa;
no es necesario mantenerlo actualizado a mano. La mayoría de los objetos no
Necesitan alguna configuración. Los objetos 'Xname', 'Yname' y 'Aname' deben ser
asignado a un pin en el microcontrolador, sin embargo. Primero elige que
microcontrolador que desee utilizar (Configuración -> Microcontrolador). Luego asignar
sus pines de E/S haciendo doble clic en ellos en la lista.

Puede modificar el programa insertando o eliminando instrucciones.
el cursor en la pantalla del programa parpadea para indicar el seleccionado actualmente
instrucción y el punto de inserción actual. Si no está parpadeando, entonces
presione <Tab> o haga clic en una instrucción. Ahora puedes eliminar el actual
instrucción, o puede insertar una nueva instrucción a la derecha o izquierda
(en serie con) o arriba o abajo (en paralelo con) el seleccionado
instrucción. Algunas operaciones no están permitidas. Por ejemplo, no hay instrucciones
despues de una bobina a su derecha.

El programa comienza con un solo peldaño. Puede agregar más peldaños seleccionando
Inserte Peldaño Antes / Después en el menú Lógica. Podrías obtener el mismo efecto
colocando muchos subcircuitos complicados en paralelo dentro de un peldaño,
pero se lee mejor usando múltiples peldaños.

Una vez que haya escrito un programa, puede probarlo en simulación y luego
puede compilarlo en un archivo .HEX para el microcontrolador de destino.


SIMULACION
==========

Para ingresar al modo de simulación, elija Simular -> Modo de simulación o presione
<Ctrl + M>. El programa se muestra de manera diferente en el modo de simulación. Ahi esta
Ya no es un cursor. Las instrucciones que se activan aparecen brillantes
rojo; las instrucciones que no aparecen en gris. Presione la barra espaciadora para
ejecute el PLC un ciclo. Para realizar un ciclo continuo en tiempo real, elija
Simular -> Iniciar simulación en tiempo real o presionar <Ctrl + R>. La exhibición de
El programa se actualizará en tiempo real a medida que cambie el estado del programa.

Puede establecer el estado de las entradas al programa haciendo doble clic,
en la lista en la parte inferior de la pantalla, o haciendo doble clic en una
Instrucción de contactos 'Xname' en el programa. Si cambia el estado de
un pin de entrada, entonces ese cambio no se reflejará en cómo el programa
se muestra hasta que el PLC realiza un ciclo; esto sucederá automáticamente si
está ejecutando una simulación en tiempo real o cuando presiona la barra espaciadora.


COMPILAR CON EL CÓDIGO NATIVO
=============================

En última instancia, el punto es generar un archivo .hex que pueda programar
en su microcontrolador. Primero debe seleccionar el número de pieza del
microcontrolador, en el menú Configuración -> Microcontrolador. Entonces usted
debe asignar un pin de E/S a cada objeto 'Xname' o 'Yname'. Haz esto
haciendo doble clic en el nombre del objeto en la lista en la parte inferior de la pantalla.
Aparecerá un cuadro de diálogo donde podrá elegir un pin no asignado de una lista.

Luego debe elegir el tiempo de ciclo con el que correrá, y debe
decirle al compilador a qué velocidad de reloj estará funcionando el micro. Esto
se configuran en el menú Configuración -> Parámetros MCU ... En general usted
no debería necesitar cambiar el tiempo del ciclo; 10 ms es un buen valor para la mayoría
aplicaciones. Escriba la frecuencia del cristal que usará
con el microcontrolador (o el resonador de cerámica, etc.) y haga clic en Aceptar.

Ahora puede generar código desde su programa. Elija Compilar -> Compilar,
o Compilar -> Compilar como ... si anteriormente compiló este programa
y desea especificar un nombre de archivo de salida diferente. Si no hay
errores, entonces LDmicro generará un archivo Intel IHEX listo para
programación en tu chip. Avertencia:si lla fue copilado y lo vuelve a copilar tenga en cuenta que
suscribira el programa antiguo .hex, para que no suceda es guardar como y cambiar el nombre.

Use cualquier software y hardware de programación que tenga para cargar el hexadecimal
archivar en el microcontrolador. Recuerde configurar los bits de configuración
(fusibles)! Para los procesadores PIC16, los bits de configuración se incluyen en
archivo hexadecimal, y la mayoría del software de programación buscará allí automáticamente.
Para los procesadores AVR, debe establecer los bits de configuración a mano.


RESISTENCIAS PULL UP
====================
Resistencias Pulll-up  + (Hacia ariba)
https://github.com/LDmicro/LDmicro/wiki/Pull-up-resistors

Todos los pines de entrada intentan establecer registros desplegables por defecto.
Desde la versión 5.3.0.4 se agregó el menú Configuración-> Establecer resistencias de entrada pull-up.

Deshabilitar resistencias pull up (Obsoleto pero posible)
https://github.com/LDmicro/LDmicro/wiki/Disable-Pull-up-resistors

Resistencias Pulll-down - (hacia a bajo)
https://github.com/LDmicro/LDmicro/wiki/Pull-down-resistors


REFERENCIA DE INSTRUCCIONES
===========================

    Terminología:
     "Nivel sensible" = salida (elemento) controlado por el nivel de la entrada.
     "Edge accionado" = la salida cambia solo en el momento
     cuando la entrada cambia de valor a la otra. Puede ser positivo
     activado por flanco (0 a 1), o activado por flanco negativo (1 a 0).
     La mayoría de los elementos de LDmicro son "sensibles al nivel", algunos elementos son
     "disparado por borde positivo".

> CONTACTO, NORMALMENTE ABIERTO    Xname           Rname          Yname
                                ----] [----     ----] [----    ----] [----

    Si la señal que entra en la instrucción es falsa, entonces la salida
     La señal es falsa. Si la señal que entra en la instrucción es verdadera,
     entonces la señal de salida es verdadera si y solo si el pin de entrada dado,
     pin de salida, o el relé interno es verdadero, de lo contrario es falso. Esta
     instrucción puede examinar el estado de un pin de entrada, un pin de salida,
     o un relé interno.


> CONTACTO, NORMALMENTE CERRADO   Xname           Rname          Yname
                               ----]/[----     ----]/[----    ----]/[----

    Si la señal que entra en la instrucción es falsa, entonces la salida
     La señal es falsa. Si la señal que entra en la instrucción es verdadera,
     entonces la señal de salida es verdadera si y solo si el pin de entrada dado,
     pin de salida, o el relé interno es falso, de lo contrario es falso. Esta
     la instrucción puede examinar el estado de un pin de entrada, un pin de salida,
     o un relé interno. Esto es lo contrario de un contacto normalmente abierto.

    CÓMO: Las operaciones lógicas AND, OR, XOR en las entradas de CONTACT
    Ver https://github.com/LDmicro/LDmicro/wiki/HOW-TO:-The-AND,-OR,-XOR-logic-operations-on-CONTACTs-inputs

> BOBINA NORMAL (Abierta)       Rname           Yname
                             ----( )----     ----( )----

    Si la señal que entra en la instrucción es falsa, entonces el
     relé interno o pin de salida se borra falso. Si la señal va
     en esta instrucción es verdadera, entonces el relé interno o la salida dada
     el pin se establece como verdadero. No tiene sentido asignar una variable de entrada a un
     bobina. Esta instrucción debe ser la instrucción más a la derecha en su peldaño.
     Nivel sensible.


> BOBINA NEGADA (Cerrada)       Rname           Yname
                             ----(/)----     ----(/)----

    Si la señal que entra en la instrucción es verdadera, entonces el
     relé interno o pin de salida se borra falso. Si la señal va
     en esta instrucción es falsa, entonces el relé interno o
     el pin de salida se establece como verdadero No tiene sentido asignar una entrada
     variable a una bobina. Esto es lo contrario de una bobina normal. Esta
     la instrucción debe ser la instrucción más derecha en su peldaño.
     Nivel sensible.


> BOBINA, SIEMPRE ACTIVA         Rname           Yname
                              ----(S)----     ----(S)----

    Si la señal que entra en la instrucción es verdadera, entonces
     El relé interno o el pin de salida se establece como verdadero. De lo contrario, el interno
     el estado del pin de salida o relé no cambia. Esta instrucción solo puede
     cambia el estado de una bobina de falso a verdadero, por lo que normalmente es
     usado en combinación con una bobina de solo reinicio --(R)--. Esta instrucción debe
     ser la instrucción más a la derecha en su peldaño.
     Simplemente puede presentar como un disparador con la entrada sensible al nivel SET.


> BOBINA, SOLO RESET            Rname           Yname
                             ----(R)----     ----(R)----

    Si la señal que entra en la instrucción es verdadera, entonces el
     relé interno o pin de salida se borra falso. De lo contrario el
     el estado interno del pin de salida o el relé no cambia. Esta instrucción
     solo puede cambiar el estado de una bobina de verdadero a falso,
     por lo tanto, se usa típicamente en combinación con una bobina de solo ajuste. Esta
     la instrucción debe ser la instrucción más a la derecha en su peldaño.
     Simplemente puede presentar como un disparador con la entrada sensible al nivel RESET.


> BOBINA, DISPARADOR T          Rname           Yname
                             ----(T)----     ----(T)----

    Un disparador en T de la bobina es un flip-flop activado por el borde (alternar, volcar, voltear).
     Un flip-flop de bobina cada borde ascendente de la condición de entrada (es decir
     cuál es la condición de entrada de falso a verdadero).
     Si se detecta un borde ascendente, si el estado de la bobina es falso, se establece como verdadero.
     Si se detecta el siguiente flanco ascendente, si el estado de la bobina es verdadero, se establece en falso.
     Esta instrucción debe ser la instrucción más a la derecha en su peldaño.
     Simplemente puede presentar como un disparador T con el positivo
     entrada activada por el borde.

Nota: Las varias bobinas con el mismo 'YName' o 'RName' pueden ser mentalmente
     representado como un microchip con múltiples entradas y una salida.
     La entrada normal e invertida transfiere directamente el estado de entrada (normal o
     invertido) a la salida cada vez en cada ciclo del PLC.
     Las entradas R, S, T bloquean (bloquean) el estado de salida.
     La entrada T es activada por flanco positivo. Las entradas R, S son sensibles al nivel.
     Si antes de R, S inserte el "OSR: ONE-SHOT RISING" = franco alto o
     "OSF: ONE-SHOT FALLING" = Franco bajo obtienes un elemento "borde positivo activado".
     Si usa solo las entradas R y S, obtiene el disparador RS clásico.
     Si agrega la entrada T, obtendrá el "RST-trigger" . Puede haber varias entradas R..R,
     o varias entradas S..S. Puede usar cualquier combinación de entradas para un 'YName'
     o bobina 'RName'.
    https://github.com/LDmicro/LDmicro/wiki/COIL


> RETARDO DE ENCENDIDO (tiempo en espera)      Tdon
                                          -[TON 1.000 s]-

    Cuando la señal que entra en la instrucción pasa de falso a verdadero,
     la señal de salida permanece falsa durante 1.000 s antes de volverse verdadera. Cuando
     la señal que entra en la instrucción va de verdadero a falso, la salida
     la señal se vuelve falsa de inmediato. El temporizador se reinicia cada vez que la entrada
     se vuelve falso; la entrada debe permanecer verdadera durante 1000 milisegundos consecutivos
     antes de que la salida se haga realidad. El retraso es configurable.

    La variable 'Tname' cuenta desde cero en unidades de tiempos de exploración.
     La instrucción TON da salida a true cuando la variable del contador es mayor
     que o igual al retraso dado. Es posible manipular el
     Contador variable en otro lugar, por ejemplo con una instrucción MOV.


              Nivel
              Logica
                   ^  La duración del pulso de entrada.
                   |  debe ser más largo que 1s
           TON     |     _________
           Entrada | ___/         \_______
                   |    |         |
                   |    | 1s      |
                   |    |<-->|    |
                   |         |    |
                   |         v    v
           TON     |          ____
           Salida  | ________/    \_______
                 --+---------------------------> Tiempo en,s
                   |


> RETARDO DE APAGADO (tiempo en encendido)        Tdoff
                                            -[TOF 1.000 s]-

    Cuando la señal que entra en la instrucción pasa de verdadero a falso,
     la señal de salida permanece verdadera por 1,000 s antes de volverse falsa. Cuando
     la señal que entra en la instrucción va de falso a verdadero,
     la señal de salida se cumple de inmediato. El temporizador se reinicia cada
     tiempo en que la entrada se vuelve falsa; la entrada debe permanecer falsa por 1000
     milisegundos consecutivos antes de que la salida se vuelva falsa. El retraso
     Es configurable.

    La variable 'Tname' cuenta desde cero en unidades de tiempos de exploración. los
     La instrucción TON da salida a true cuando la variable del contador es mayor
     que o igual al retraso dado. Es posible manipular el
     Contador variable en otro lugar, por ejemplo con una instrucción MOV.


              Nivel
              Logico
                   ^  La duración del pulso de entrada debe ser
                   |     más largo que el ciclo del PLC
           TOF     |        _
           Entrada | ______/ \_________
                   |       | |
                   |       | | 1s
                   |       | |<-->|
                   |       |      |
                   |       v      v
           TOF     |        ______
           Salida  | ______/      \____
                 --+----------------------> Tiempo en,s
                   |


> TEMPORIZADOR ALTO              Thi
                           -[THI 1.000 s]-

    Cuando la señal que entra en la instrucción pasa de falso a verdadero,
     La señal de salida es verdadera durante 1.000 s. El retraso es configurable.
     La señal de salida se restablece después de 1.000 s, el contador interno del temporizador
     se restablece después de 1,000 sy si la entrada es falsa.


               Nivel
              Logico
                   ^  La duración del pulso de entrada debe ser
                   |      El más largo que el ciclo del PLC
           THI     |     _           ________
           Entrada | ___/ \_________/        \_______
                   |    |           |
                   |    | 1s        | 1s
                   |    |<-->|      |<-->|
                   |    |    |      |    |
                   |    v    v      v    v
           THI     |     ____        ____
           Salida  | ___/    \______/    \___________
                 --+------------------------------------> Tiempo en,s
                   |


> TEMPORIZADOR BAJO             Tlo
                          -o[TLO 1.000 s]-

    Cuando la señal que entra en la instrucción pasa de verdadero a falso,
     la señal de salida es falsa durante 1.000 s. El retraso es configurable.
     La señal de salida se establece como verdadera después de 1.000 s, el contador interno del temporizador
     se restablece después de 1,000 sy si la entrada es verdadera.


              Nivel
              Logico
                   ^  La duración del pulso de entrada debe ser
                   |     más largo que el ciclo del PLC
           TLO     | ___   _________          _______
           Entrada |    \_/         \________/
                   |    |           |
                   |    | 1s        | 1s
                   |    |<-->|      |<-->|
                   |    |    |      |    |
                   |    v    v      v    v
           TLO     | ___      ______      ___________
           Salida  |    \____/      \____/
                 --+------------------------------------> Tiempo en,s
                   |

    See https://github.com/LDmicro/LDmicro/wiki/TON,-TOF,-etc.


> TEMPORIZADOR RETENTIVO        Trto
                           -[RTO 1.000 s]-

    Esta instrucción realiza un seguimiento de cuánto tiempo su entrada ha sido verdadera (HI=Alto).
     Si su entrada ha sido verdadera durante al menos 1,000 s, entonces la salida es
     cierto. De lo contrario, la salida es falsa. La entrada no necesita haber sido
     verdadero por 1000 milisegundos consecutivos; si la entrada se cumple
     por 0.6 s, luego falso por 2.0 s, y luego verdadero por 0.4 s, luego el
     La salida se hará realidad. Después de que la salida se vuelva verdadera, seguirá siendo verdadera
     incluso después de que la entrada sea falsa, siempre que la entrada haya sido verdadera
     por más de 1.000 s. Por lo tanto, este temporizador debe restablecerse manualmente,
     usando la instrucción de reinicio.

    La variable 'Tname' cuenta desde cero en unidades de tiempos de exploración.
     La instrucción TON da salida a true cuando la variable del contador es mayor
     que o igual al retraso dado. Es posible manipular el
     Contador variable en otro lugar, por ejemplo con una instrucción MOV.


              Nivel
              Logico
                   ^  La duración total de los pulsos de entrada (Alta)es más de 1 s
                   |  t1+t2+..+tn >= 1s
                   |
           RTO     |     __     _    _________
           Entrada | ___/  \___/ \__/         \________
                   |    |  |   | |  |
                   |    |t1|   | |  |tn                   Trto
                   |    |<>|  >|-|< |<>|                  RESET
                   |           t2      |                  |
                   |                   v                  v
           RTO     |                    __________________
           Salida  | __________________/                  \___
                 --+-------------------------------------------> Tiempo en,s
                   |


> TEMPORIZADOR RETENTIVO BAJO      Trtl
                             -o[RTL 1.000 s]-

    RTL funciona como RTO, pero captura entradas de bajo nivel.
     Esta instrucción realiza un seguimiento de cuánto tiempo, su entrada ha sido falsa (BAJA).
     Si su entrada ha sido falsa durante al menos 1,000 s, entonces la salida es
     cierto. De lo contrario, la salida es falsa.
     Después de que la salida sea verdadera, seguirá siendo verdadera incluso después de la entrada
     se hace realidad Por lo tanto, este temporizador debe restablecerse manualmente,
     usando la instrucción de reinicio.


              Nivel
              Logico
                   ^  La duración total de la entrada BAJA es más de 1 s
                   |  t1+t2+..+tn >= 1s
                   |
           RTL     | ___    ___   __           ________
           Entrada |    \__/   \_/  \_________/
                   |    |  |   | |  |
                   |    |t1|   | |  |tn                   Trtl
                   |    |<>|  >|-|< |<>|                  RESET
                   |           t2      |                  |
                   |                   v                  v
           RTL     |                    __________________
           Salida  | __________________/                  \___
                 --+-------------------------------------------> Tiempo en,s
                   |


> CYCLIC TIMER (TEMPORIZADOR CÍCLICO)    Tmeander
                                      -[TCY 500 ms]-

    Si la señal de entrada es verdadera, esta instrucción produce un meandro con
     período (500ms + 500ms) = 1s y frecuencia 1 Hz. Si la señal entra
     la instrucción es falsa, entonces la señal de salida es falsa.

   Si el valor de Tmeander = tiempo de ciclo del PLC, el TCY es igual a OSC.


              Nivel
              Logico
                   ^  La duración del pulso de entrada es superior a 1 s.
           TCY     |     ______________________
           Entrada | ___/                      \_______
                   |    |                      |
                   |    |  1s    1s    1s      |
                   |    |<--->|<--->|<--->|    |
                        |     |     |     |    v
           TCY     |    v   __|   __|   __|   _
           Salida  | ______/  \__/  \__/  \__/ \_______
                 --+----------------------------------------> Tiempo en,s
                   |


> TON, TOF, THI, TLO, RTO, RTL, TCY timers      Ton
                                           -[TON valor]-

    Actualizado en la versión 4.4.1.0
     Puede usar una variable general como retraso del temporizador.
     Debe calcular el valor correcto (correcto) de la variable de acuerdo con
     El tiempo de ciclo del PLC.
     Retardo del temporizador (ms) = Tplc (ms) * Valor de retardo
   ||                                                       ||
   ||                                             Adc       ||
   ||-----------------------------------------{READ ADC}----||
   ||                                                       ||
   ||                                                       ||
   ||       X1               T1                   Y1        ||
   ||-------] [-----------[TON Adc]---------------( )-------||
   ||                                                       ||


> Conversor de TIEMPO a CONTADOR       Tconst
                                   -[T2CNT 10 ms]-

    La instrucción 'Convertidor de TIEMPO a CONTADOR' obtiene el tiempo
     constante en ms, lo convierte a los temporizadores (TON, TOF, ...) -
     valor específico y lo guarda en la variable Const para usarlo en contadores más adelante.
     Ver https://github.com/LDmicro/LDmicro/wiki/TIME-to-COUNTER-converter


> RESET (Reinico)                Trto             Citems
                             ----{RES}----     ----{RES}----

    Esta instrucción restablece un temporizador o un contador. Los temporizadores TON y TOF.
     se restablece automáticamente cuando su entrada es falsa o verdadera, por lo que RES
     No es necesario para estos temporizadores, pero es posible. Temporizadores RTO y
     Los contadores CTU / CTD no se reinician automáticamente, por lo que deben reiniciarse
     a mano usando una instrucción RES. Cuando la entrada es verdadera, el contador o
     el temporizador se reinicia; cuando la entrada es falsa, no se toman medidas. Esta
     la instrucción debe ser la instrucción más correcta en su peldaño.
     ¡Nota! RES restablece solo el contador numérico dentro de RTO, CTU / CTD,
     no sus salidas!


> RESET (Reinicio)                  PWM
                               ----{RES}----

    Esta instrucción deshabilita la salida PWM y la establece en nivel bajo.
     También puede establecer otra frecuencia base PWM mediante SET PWM DUTY CYCLE
     después de la activación, RESET PWM.

     Ver SET PWM DUTY CYCLE a continuación.


> DELAY (RETRASO)               1 us
                           ---[DELAY]---

    La instrucción DELAY causa un retraso. La instrucción DELAY no
     use cualquier temporizador / contador. Las instrucciones NOP y JMP (Dirección actual + 1)
     se usan para hacer el retraso.
    See https://github.com/LDmicro/LDmicro/wiki/DELAY-us


> Conversor de TIEMPO a RETRASO       Tconst
                                 -[T2DELAY 10 us]-

    La instrucción 'Convertidor de TIEMPO a RETARDO' obtiene el tiempo constante en 'nosotros',
     lo convierte al valor específico de DELAY y lo guarda en la variable Tconst
     para usar como parámetro de la instrucción DELAY más tarde.


> ASCENDENTE DE UN SOLO DISPARO (Franco)     _     _
                                        --[_/ OSR_/ \_]--

    Esta instrucción normalmente genera falso. Si la entrada de la instrucción
     es cierto durante este escaneo y fue falso durante el escaneo anterior
     entonces la salida es verdadera. Por lo tanto, genera una exploración de pulso uno
     de ancho en cada borde ascendente de su señal de entrada, es decir, univibrador. Esta
     la instrucción es útil si desea desencadenar eventos fuera del alza
     borde de una señal.


> DESCENDENTE CAÍDA DE UN DISPARO  Franco)   _       _
                                          --[ \_OSF_/ \_]--

    Esta instrucción normalmente genera falso. Si la entrada de la instrucción
     es falso durante este escaneo y fue cierto durante el escaneo anterior
     entonces la salida es verdadera. Por lo tanto, genera una exploración de pulso uno
     ancho en cada borde descendente de su señal de entrada, es decir, univibrador. Esta
     la instrucción es útil si desea activar eventos de la caída
     borde de una señal.


                              Esto es la
                               señal de entrada
                              v v
                                _     _
                           --[_/ OSR_/ \_]--
                              _       _
                           --[ \_OSF_/ \_]--
                                _   _   _
                           --[_/ ODR \_/ ]--
                              _     _   _
                           --[ \_ODF \_/ ]--

                                    ^   ^
                                    esto es la
                                     señal de salida




                     Nivel
                     Logico
                          ^  La duración del pulso de entrada es de cinco ciclos.
                  OSR, OSF|     _________
                  Entrada | ___/         \_______
                          |
                  OSR     |     _
                  Salida  | ___/ \_______________
                          |
                  OSF     |               _
                  Salida  | _____________/ \_____
                        --+---------------------------> Tiempo
                          |
       Tiempo de ciclo del PLC N+ 0 1 2 3 4 5 6 7 8




                     Nivel
                     Logico
                          ^      Single-cycle input pulse
                  OSR, OSF|     _
                  Entrada | ___/ \_______
                          |
                  OSR     |     _
                  Salida  | ___/ \_______
                          |
                  OSF     |       _
                  Salida  | _____/ \_____
                        --+------------------> Tiempo
                          |
       Tiempo de ciclo del PLC  N+ 0 1 2 3 4 5 6


> ONE DROP if FALLING
> NIVEL BAJO DE UN DISPARO (Franco)      _     _   _
                                      --[ \_ODF \_/ ]--

    Esta instrucción normalmente emite ture. Si la entrada de la instrucción es
     falso durante este escaneo y fue cierto durante el escaneo anterior, entonces el
     La salida es falsa. Por lo tanto, genera un pulso de bajo nivel de un escaneo de ancho
     en cada borde descendente de su señal de entrada, es decir, univibrador. Esta
     la instrucción es útil si desea desencadenar eventos fuera del límite descendente
     de una señal



                      Nivel
                     Logico
                          ^  La duración del pulso de entrada es de cinco ciclos.
                  ODF     | ___           _______
                  Entrada |    \_________/
                          |
                  ODF     | ___   _______________
                  Salida  |    \_/
                        --+---------------------------> Tiempo
                          |
       Tiempo de ciclo del PLC N+ 0 1 2 3 4 5 6 7 8



                     Nivel
                     Logico
                          ^     Pulso de entrada de ciclo único
                  ODF     | ___   _______
                  Entrada |    \_/
                          |
                  ODF     | ___   _______
                  Salida  |    \_/
                        --+------------------> Tiempo
                          |
       Tiempo de ciclo del PLC N+ 0 1 2 3 4 5 6



> OSCILADOR                        _   _
                           --[OSC_/ \_/ \_]--

                             F=1/(2*Tcycle)


                     Nivel
                     Logico
                          ^  La duración del pulso de entrada es de siete ciclos.
                  OSC     |     ____________
                 Entrada  | ___/            \_______
                          |
                  OSC     |     _   _   _
                  Salida  | ___/ \_/ \_/ \_____________
                          |
                        --+---------------------------> Tiempo
                          |
       Tiempo de ciclo del PLC N+ 0 1 2 3 4 5 6 7 8


    Si la señal de entrada es verdadera, esta instrucción produce un meandro con
     período (2 * tiempo de ciclo del PLC), es decir, multivibrador. Si la señal entra
     la instrucción es falsa, entonces la señal de salida es falsa.


> CIRCUITO CERRADO, CIRCUITO ABIERTO
                           ----+----+----      ----+     +----

    La condición de salida de un cortocircuito es siempre igual a su
     Condición de entrada. La condición de salida de un circuito abierto es siempre
     falso. En su mayoría son útiles para depurar, el corto temporal
     circuito o desconectar un circuito eléctrico.

    Ver más https://github.com/LDmicro/LDmicro/wiki/OPEN-CIRCUIT,-SHORT-CIRCUIT
    Nota: tenga en cuenta.
   || ; La demostración de efectos secundarios.                          ||
   ||                                                          Y1        ||
   ||----------------------------------------------------------( )-------||
   || ; Y1 es 1.                                                         ||
   ||                                                                    ||
   ||    abierto                                               Y1        ||
   ||----+      +----------------------------------------------( )-------||
   || ; El elemento COIL (BOBINA) siempre establece la salida de acuerdo ||
   || ; con su entrada Y1 es 0 ahora.                                    ||
   ||                                                                    ||
   ||    Cerrado                                               Y1        ||
   ||----+----+------------------------------------------------( )-------||
   || ; Y1 vuelve a ser 1 otra vez                                       ||


> RELÉ DE CONTROL MAESTRO
                           -{MASTER RLY}-

    Por defecto, la condición de renglón de cada renglón es verdadera. Si un maestro
     la instrucción de relé de control se ejecuta con una condición de renglón de
     falso, entonces la condición de renglón para todos los renglones siguientes se convierte en
     falso. Esto continuará hasta el próximo relé de control maestro
     se alcanza la instrucción (independientemente de la condición de renglón de ese
     instrucción). Por lo tanto, estas instrucciones deben usarse en pares:
     uno para (tal vez condicionalmente) iniciar la sección posiblemente deshabilitada,
     y uno para terminarlo.
     Ver https://github.com/LDmicro/LDmicro/wiki/MASTER-CONTROL-RELAY


> MOVE MOVER                {MOV destvar:=}      {MOV  Tret :=}
                           -{          123}-    -{      srcvar}-

    Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino igual a la variable fuente dada o
     constante. Cuando la entrada a esta instrucción es falsa, nada
     sucede Puede asignar a cualquier variable con la instrucción de movimiento;
     Esto incluye variables de estado de contador y contador, que pueden ser
     distinguido por la principal 'T' o 'C'. Por ejemplo, una instrucción
     mover 0 a 'Tretentive' es equivalente a una instrucción de reinicio (RES)
     para ese temporizador Esta instrucción debe ser la instrucción más a la derecha.
     en su peldaño.


> OPERACIÓN ARITMÉTICA       {ADD  kay  :=}       {SUB  Ccnt :=}
                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-

>                            {MUL  dest :=}       {DIV    dv :=}
                            -{ var * -990 }-     -{ dv / -10000}-

    Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino igual a la expresión dada. Los operandos
     pueden ser variables (incluidas las variables de temporizador y contador)
     o constantes Estas instrucciones usan matemática firmada de 16 bits. Recuerda
     que el resultado se evalúa cada ciclo cuando la condición de entrada
     cierto. Si está aumentando o disminuyendo una variable (es decir, si
     la variable de destino también es uno de los operandos) entonces usted
     probablemente no quiera eso; normalmente usarías un solo disparo para que
     se evalúa solo en el borde ascendente o descendente de la entrada
     condición. La división se trunca; 7/3 = 2. Esta instrucción debe ser
     la instrucción más a la derecha en su peldaño.


> MODULO                   {MOD     dest:=}
                          -{src     %    2}-

    Resto de la división 7% 3 = 1
     Ver https://en.wikipedia.org/wiki/Modulo_operation


> NEGATIVO                 {NEG     dest:=}
                          -{         - src}-

    Negativo - {NEG a: = -a} - es el equivalente optimizado a - {SUB a: = 0 - a} -


> OPERATION bit A bit        {AND  var1 :=}       {OR   Ccnt :=}
                            -{var2 & var3 }-     -{ Ccnt | 0o07}-

>                            {XOR  dest :=}       {NOT  dv :=  }
                            -{ var ^ 0xAA }-     -{ ~0b11001100}-

    Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino igual a la expresión dada. Los operandos
     pueden ser variables (incluidas las variables de temporizador y contador)
     o constantes Recuerde que el resultado se evalúa en cada ciclo.
     cuando la condición de entrada es verdadera.
     Por favor lee http://en.wikipedia.org/wiki/Bitwise_operation


> INTERCAMBIAR  bit A bit    {      dest:=}
                            -{SWAP     src}-

    Esta operación intercambia los nibbles y los bytes.
     Ver https://en.wikipedia.org/wiki/Nibble
    Cuando el tamaño de las variables es
    1 - luego, a nivel bit, intercambia los nibbles en un BYTE, es decir, 0x73 -> 0x37

                     MSB       bits       LSB
                      7  6  5  4  3  2  1  0
                      \________/  \________/
                             ^      ^
                             |      |
                             +------+
        Cambios de bits:
           7 <-> 3
           6 <-> 2
           5 <-> 1
           4 <-> 0

    2 - luego intercambie los bytes en una PALABRA, es decir 0x7733 -> 0x3377

            MSB                  bits                   LSB
             15 14 13 12 11 10 9 8  7  6  5  4  3  2  1  0
             \___________________/  \____________________/
                             ^           ^
                             |           |
                             +-----------+
        Cambios de bits:
          15 <-> 7
          14 <-> 6
             ...
           9 <-> 1
           8 <-> 0

    3 - luego, a nivel bit, intercambie los nibbles de 1 byte y los bytes 2 y 0 en un INT24, es decir, 0x775A33 -> 0x33A577

       MSB                             bits                          LSB
        23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8 7 6 5 4 3 2 1 0
        \_____________________/ \_________/ \_________/ \_____________/
                    ^                ^           ^             ^
                    |                |           |             |
                    |                +-----------+             |
                    +------------------------------------------+
        Cambios de bits:
          23 <->  7
             ...
          16 <->  0
          15 <-> 11
             ...
          12 <->  8

    4 - a continuación, intercambie los bytes 3 y 0 y los bytes 2 y 1 en un DWORD, es decir, 0x7755AA33 -> 0x33AA5577

        MSB                                          bits                                  LSB
        31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
        \_____________________/ \_____________________/ \___________________/ \_____________/
                    ^                            ^           ^                     ^
                    |                            |           |                     |
                    |                            +-----------+                     |
                    +--------------------------------------------------------------+
        Cambios de bits:
          31 <->  7
             ...
          24 <->  0
          23 <-> 15
             ...
          16 <->  8


> bit A bit OPUESTO          {      dest:=}
                            -{OPPOSITE src}-

    Esta operación invierte la secuencia de bits al contrario.
     El MSB se mueve al LSB, y el LSB se mueve al MSB y etc.

                     MSB      bits       LSB
                      n n-1 n-2 ... 2  1  0
                      ^  ^   ^      ^  ^  ^
                      |  |   |      |  |  |
                      |  |   +------+  |  |
                      |  +-------------+  |
                      +-------------------+


> CAMBIO ARITMÉTICO: SHL, SHR.   {SHL  var1 :=}     {SHR   cnt :=}
                                -{var2 << 2   }-   -{  cnt >>  1 }-

    Ver https://en.wikipedia.org/wiki/Arithmetic_shift

    SHL - desplazamiento aritmético a la izquierda
        MSB                    LSB
             MSB-1         1    0
    C <- x <- x <- .... <- x <- x <- 0


    SHR - desplazamiento aritmético a la derecha
        MSB                    LSB
             MSB-1         1    0
    /--> x -> x -> .... -> x -> x -> C
    \   /
     <--


    Nota: MSB = bit más significativo, LSB = bit menos significativo


> CAMBIO LÓGICO A LA DERECHA SR0.  {SR0  dest :=}
                                  -{var  sr0  3 }-

    Ver https://en.wikipedia.org/wiki/Logical_shift

    SR0 - desplazamiento lógico a la derecha
        MSB                    LSB
             MSB-1         1    0
    0 -> x -> x -> .... -> x -> x -> C


    NOTA: El desplazamiento lógico a la izquierda es equivalente al desplazamiento aritmético SHL a la izquierda.


> CAMBIO CIRCULAR: ROL, ROR.     {ROL  dest :=}     {ROR    dv :=}
                                -{ var rol 4  }-   -{var ror 4   }-

    Ver https://en.wikipedia.org/wiki/Circular_shift

    ROL - desplazamiento circular (rotación bit a bit) a la izquierda
        MSB                    LSB
             MSB-1         1    0
    C <- x <- x <- .... <- x <- x
         v                      ^
         \_________>____________/


    ROR - desplazamiento circular (rotación bit a bit) derecha
        MSB                    LSB
             MSB-1         1    0
         x -> x -> .... -> x -> x -> C
         ^                      v
         \_________<____________/

  SHL, SHR, SR0, ROL, ROR:
    Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino igual a la expresión dada. Los operandos
     pueden ser variables (incluidas las variables de temporizador y contador)
     o constantes Recuerde que el resultado se evalúa en cada ciclo.
     cuando la condición de entrada es verdadera.


> OPERACIONES CON UN BIT    {           var}       {           var}
                           -{SET Bit    bit}-     -{CLR Bit    bit}-

    -{SET Bit var, bit}- En la variable 'var' establece el número de bit 'bit'.
    -{CLR Bit var, bit}- En la variable 'var', borre el número de bit 'bit'.

    'Bit' significa número de bit, no máscara de bit. Por ejemplo,
     configurar el bit número 4 en la variable 'var'
                      v
     Bit número:  76543210
     'var'      :  xxx1xxxx
                      ^
    debe escribir    ^
         {          var}               {             var}
        -{SET Bit     4}-        not  -{SET Bit     0x10}-

    y es equivalente a
         {OR     var :=}
        -{   var | 0x10}-


    Para borrar el bit número 4 en la variable 'var'
     debes escribir
         {          var}               {             var}
        -{CLR Bit     4}-        not  -{CLR Bit     0x10}-

    y es equivalente a
         {AND    var :=}
        -{   var & 0xEF}-

    var debe ser una variable, no un valor literal.
     El tamaño de var debe ser de 1 a 4 bytes.
     El bit puede ser un número literal o una variable.
     el bit puede tener un valor de 0-7 si tamaño de (var) == 1 byte,
                            0-15 si tamaño (var) == 2 bytes,
                            0-23 si tamaño (var) == 3 bytes,
                            0-31 si tamaño (var) == 4 bytes.

    Aprenda a usar SetBit (), ClearBit () para deshabilitar resistencias pull up
    vea https://github.com/LDmicro/LDmicro/wiki/Disable-Pull-up-resistors


> COMPARAR              [var ==]        [var >]        [1 >=]
                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-

>                       [var !=]       [-4 <   ]       [1 <=]
                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-

    Si la entrada a esta instrucción es falsa, la salida es falsa. Si
     la entrada es verdadera, entonces la salida es verdadera si y solo si
     La condición es verdadera. Esta instrucción se puede usar para comparar (igual,
     es mayor que, es mayor o igual que, no es igual,
     es menor que, es menor o igual que) una variable a una variable,
     o para comparar una variable con una constante con signo de 16 bits.


> ESTADO DE PRUEBA DE UN BIT   [             var]       [             var]
                              -[if Bit SET   bit]-     -[if Bit CLR   bit]-

    Si la entrada a esta instrucción es falsa, la salida es falsa. Si
     la entrada es verdadera, entonces la salida es verdadera si y solo si
     La condición es verdadera. Esta instrucción se puede usar solo para verificar el estado
     un bit de la variable
     'Bit' significa número de bit, no máscara de bit. Vea arriba la operación del bit SET.

    La operación - {si Bit SET var, 0} - es una condición equivalente 'Si var es impar'.
    La operación - {si Bit CLR var, 0} - es una condición equivalente 'Si var es par'.

    var debe ser una variable, no un valor literal.
     El tamaño de var debe ser de 1 a 4 bytes.
     El bit puede ser un número literal o una variable.
     el bit puede tener un valor de 0-7 si tamaño de (var) == 1 byte,
                            0-15 si tamaño de(var) == 2 bytes,
                            0-23 si tamaño de(var) == 3 bytes,
                            0-31 si tamaño de(var) == 4 bytes.


> CONTADOR                     Cname          Cname
                           --[CTU >= 5]--  --[CTD > -5]--

    Un contador aumenta (CTU, cuenta atrás) o disminuye (CTD, cuenta
     abajo) el recuento asociado en cada borde ascendente de la entrada de renglón
     condición (es decir, la condición de entrada del renglón va de falso a
     cierto). La condición de salida del contador es verdadera si el contador
     variable CTU> = 5 (CTD> -5), y falso en caso contrario. los
     la condición de salida del renglón puede ser verdadera incluso si la condición de entrada es
     falso; solo depende de la variable del contador. Puedes tener CTU
     y las instrucciones CTD con el mismo nombre, para incrementar y
     disminuir el mismo contador. La instrucción RES puede restablecer un contador,
     o puede realizar operaciones de variables generales en la variable de conteo.


> CONTADOR CIRCULAR            Cname             Cname
                           --{CTC 0:7}--     --{CTR 7:0}--

    Un contador circular funciona como un contador CTU normal, excepto que
     después de alcanzar su límite superior, restablece su variable de contador
     volver a 0. Por ejemplo, el contador que se muestra arriba contaría 0, 1,
     2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, ... Esto es útil en
     combinación con declaraciones condicionales en la variable 'Cname';
     puedes usar esto como un secuenciador. Contadores CTC reloj en aumento
     borde de la condición de condición de entrada de renglón.
     Obsoleto: esta instrucción debe ser la instrucción más correcta en su peldaño.

    CTR es contador circular reversible. igual CTC pero con decremento
     contando por dentro. Por ejemplo, el contador que se muestra arriba contaría
     7, 6, 5, 4, 3, 2, 1, 0, 7, 6, 5, 4, 3, 2, 1, 0, 7, ...

   Se agregó el valor 'Inicio' en los contadores CTU, CTD, CTC, CTR.
     La CTU, el contador CTC comienzan desde 'Inicio' y cuentan hasta el valor 'Máx.'
     CTC genera impulso de sobrellenado (carry) cuando Counter == Max.
     Para el trabajo adecuado, el valor 'Inicio' debe ser menor que el valor 'Máx.'

    El contador CTD, CTR comienza desde 'Inicio' y cuenta atrás hasta el valor 'Min'.
     El CTR genera un impulso de sobrellenado (préstamo) cuando el Contador == Min.
     Para el trabajo adecuado, el valor 'Inicio' debe ser mayor que el valor 'Mínimo'.

   ||   Rnew      Tnew                                    Rnew      ||
   ||----] [----[TON 1 s]----------------------------------(/)------||
   ||                                                               ||
   ||                                                               ||
   ||   Rnew       Css           Cmm          Chh         Cdays     ||
   ||----] [----[CTC 0:59]---[CTC 0:59]---[CTC 0:23]---[CTC 0:364]--||
   ||                                                               ||

    Actualizado en la versión 4.4.1.0
     Tipo de entradas de elementos de escalera
    https://github.com/LDmicro/LDmicro/wiki/Kind-of-inputs-of-ladder-elements

   ||                               ||
   ||  X1          CTU1:0      Y1   ||
   ||--] [---+---/[CTU>=10]----( )--|| '/' Entrada dinámica activa en 0 a 1
   ||        |                      || transición para la lógica positiva.
   ||        |     CTU2:0      Y2   ||
   ||        +---\[CTU>=10]----( )--|| '\' Entrada dinámica activa en 1 a 0
   ||        |                      || transición para la lógica positiva.
   ||        |     CTU3:0      Y3   ||
   ||        +----[CTU>=10]----( )--|| '-' Entrada lógica estática directa.
   ||        |                      || Activo en el exterior 1.
   ||        |     CTU4:0      Y4   ||
   ||        +---o[CTU>=10]----( )--|| 'o' Entrada lógica estática inversa.
   ||                               || Negación lógica en la entrada.
   ||                               || Externo 0 produce interno 1.

    Nota: Los contadores de versiones anteriores tienen la entrada dinámica "/".
     Estos dos peldaños son equivalentes en la nueva versión.
   ||                                                   ||
   ||       X1               C1                         ||
   ||-------] [----------/[CTC  0:9]---                 ||
   ||                                                   ||
   ||                                                   ||
   ||       X1             _     _            C2        ||
   ||-------] [---------[_/ OSR_/ \_]------[CTC  0:9]---||
   ||                                                   ||

    '-/' es una entrada positiva activada por flanco (flanco ascendente).
    '-\' es una entrada de activación por flanco negativo (flanco descendente).
    '--' es entrada estática activa de alto nivel.
    '--' es entrada estática, activa a un nivel alto.
    '-o' es entrada estática, activa a un nivel bajo.


> REGISTRO DE DESPLAZAMIENTO      {SHIFT REG   }
                                 -{ reg0..3    }-

   Un registro de desplazamiento está asociado con un conjunto de variables. Por ejemplo,
     este registro de desplazamiento está asociado con las variables `reg0 ',` reg1',
     `reg2 'y` reg3'. La entrada al registro de desplazamiento es 'reg0'. En
     cada borde ascendente de la condición de renglón, el registro de desplazamiento
     Desplazar a la derecha. Eso significa que asigna `reg3: = reg2 ',` reg2: =
     reg1 '. y `reg1: = reg0 '. `reg0 'no se modifica. Un gran turno
     registrarse puede consumir fácilmente mucha memoria. Esta instrucción debe
     ser la instrucción más correcta en su peldaño.

> TABLA DE BÚSQUEDA         {dest :=     }
                           -{ LUT[i]     }-

    Una tabla de búsqueda es un conjunto ordenado de n valores. Cuando el peldaño
     condición es verdadera, la variable entera 'dest' se establece igual a la
     entrada en la tabla de búsqueda correspondiente a la variable entera
     'i'. El índice comienza desde cero, por lo que 'i' debe estar entre 0 y
     (n-1) El comportamiento de esta instrucción no se define si el
     El índice está fuera de este rango. Esta instrucción debe ser la más a la derecha
     en su peldaño.

    Ver https://github.com/LDmicro/LDmicro/wiki/HOW-TO:-Look-Up-Table,-UART-SEND


> TABLA LINEAL POR TRAMOS   {yvar :=     }
                           -{ PWL[xvar]  }-

    Esta es una buena manera de aproximar una función complicada o
     curva. Podría, por ejemplo, ser útil si está intentando aplicar
     una curva de calibración para convertir un voltaje de salida sin procesar de un sensor
     en unidades más convenientes.

    Suponga que está intentando aproximar una función que convierte
     una variable de entrada entera, x, a una variable de salida entera, y. Tú
     Conocer la función en varios puntos; por ejemplo, podrías saber que

        f(0)   = 2
        f(5)   = 10
        f(10)  = 50
        f(100) = 100

    Esto significa que los puntos

        (x0, y0)   = (  0,   2)
        (x1, y1)   = (  5,  10)
        (x2, y2)   = ( 10,  50)
        (x3, y3)   = (100, 100)

    Acuéstate en esa curva. Puedes ingresar esos 4 puntos en una tabla
     asociado con la instrucción lineal por partes. El lineal por partes
     la instrucción analizará el valor de xvar y establecerá el valor de
     Yvar. Establecerá yvar de tal manera que la curva lineal por partes
     pasará por todos los puntos que le des; por ejemplo,
     si configura xvar = 10, entonces la instrucción establecerá yvar = 50.

    Si le da a la instrucción un valor de xvar que se encuentra entre dos
     de los valores de x para los que le ha dado puntos, entonces el
     la instrucción establecerá yvar para que (xvar, yvar) quede en la recta
     línea que conecta esos dos puntos en la tabla. Por ejemplo, xvar =
     55 da una salida de yvar = 75. (Los dos puntos en la tabla son
     (10, 50) y (100, 100). 55 está a medio camino entre 10 y 100, y 75
     está a medio camino entre 50 y 100, entonces (55, 75) se encuentra en la línea que
     conecta esos dos puntos).

    Los puntos deben especificarse en orden ascendente por coordenada x. Eso
     puede no ser posible realizar operaciones matemáticas requeridas para
     ciertas tablas de búsqueda que usan matemática entera de 16 bits; si este es el
     caso, entonces LDmicro te avisará. Por ejemplo, esta tabla de consulta
     producirá un error:

        (x0, y0)    = (  0,   0)
        (x1, y1)    = (300, 300)

    Puede corregir estos errores haciendo la distancia entre puntos en
     La mesa más pequeña. Por ejemplo, esta tabla es equivalente a la tabla
     dado anteriormente, y no produce un error:

        (x0, y0)    = (  0,   0)
        (x1, y1)    = (150, 150)
        (x2, y2)    = (300, 300)

    Casi nunca debería ser necesario usar más de cinco o seis
     puntos. Agregar más puntos hace que su código sea más grande y más lento
     ejecutar. El comportamiento si pasa un valor de 'xvar' mayor que
     la coordenada x más grande en la tabla o menos que la x más pequeña
     La coordenada en la tabla no está definida. Esta instrucción debe ser la
     instrucción más correcta en su peldaño.


> CONVERTIDOR A/D LEER           Aname
                           --{READ ADC}--

    LDmicro puede generar código para usar los convertidores A / D integrados en
     ciertos microcontroladores. Si la condición de entrada a esta instrucción
     es cierto, se adquiere una sola muestra del convertidor A / D y
     almacenado en la variable 'Aname'. Esta variable puede ser posteriormente
     manipulado con operaciones variables generales (menor que, mayor que,
     aritmética, y así sucesivamente). Asigne un pin a la variable 'Axxx' en el
     de la misma manera que asignarías un pin a una entrada o salida digital,
     haciendo doble clic en la lista en la parte inferior de la pantalla. Si
     la condición de entrada a este renglón es falsa, entonces la variable 'Aname'
     se deja sin cambios.

    Para todos los dispositivos compatibles actualmente, la entrada de 0 voltios corresponde a
     una lectura de ADC de 0 y una entrada igual a Vdd (la tensión de alimentación)
     corresponde a una lectura de ADC de 1023. Si está utilizando un AVR, entonces
     conecta AREF a Vdd. Puede usar operaciones aritméticas para escalar el
     leer a las unidades más convenientes después, pero recuerde que usted
     están usando matemáticas enteras. En general, no todos los pines estarán disponibles
     para usar con el convertidor A/D. El software no te permitirá
     asignar pines que no sean A/D a una entrada analógica. Esta instrucción debe ser
     la instrucción más a la derecha en su peldaño.

    Actualizado: Referencia de voltaje ADC.
     El voltaje de referencia para el ADC (Vref) indica la conversión
     gama para el ADC. Los canales de un solo extremo que excedan Vref resultarán
     en códigos cercanos a 0x3FF (1023). Vref se puede seleccionar como AVCC,
     referencia interna de 2.56V, referencia interna de 1.1V o pin externo Aref.
     El parámetro REFS = 0 es compatible con versiones anteriores de LDmicro.

    Ver https://github.com/LDmicro/LDmicro/wiki/ADC-Voltage-Reference
    https://github.com/LDmicro/LDmicro/wiki/How-to-measure-battery-voltage
    https://github.com/LDmicro/LDmicro/wiki/How-to-measure-voltage-(PIC)


> CONFIGURAR EL CICLO DE TRABAJO PWM     duty_cycle  3.8 kHz
                                       -{PWM            PWM1}-

    LDmicro puede generar código para usar el periférico PWM integrado en
     ciertos microcontroladores. Si la condición de entrada a esta instrucción
     es cierto, entonces el ciclo de trabajo del periférico PWM se establece en
     valor de la variable duty_cycle.
     Actualizado: LDmicro v4.3.5 permite seleccionar una resolución PWM más alta:
       0-100% (resolución máxima de 6,7 bits)
       0-256 (resolución máxima 8 bits)
       0-512 (resolución máxima 9 bits)
       0-1024 (resolución máxima 10 bits)
     El ciclo de trabajo debe ser un número entre 0 y 100/256/512/1024;
     0 corresponde a siempre bajo, y 100/256/512/1024 corresponde a
     siempre alto. (Si está familiarizado con el funcionamiento del periférico PWM,
     luego observe que eso significa que LDmicro escala automáticamente
     ciclo de trabajo variable desde porcentaje (o valor binario) hasta períodos de reloj PWM).

    Puede especificar la frecuencia PWM objetivo, en Hz. La frecuencia que
     que especifique podría no ser exactamente posible, dependiendo de cómo
     se divide en la frecuencia de reloj del microcontrolador. LDmicro will
     elija la frecuencia alcanzable más cercana; si el error es grande entonces
     Te lo advertirá. Las velocidades más rápidas (frecuencia PWM) pueden sacrificar la resolución.

    Esta instrucción debe ser la instrucción más a la derecha en su peldaño.
     El tiempo de ejecución de la lógica de escalera consume un temporizador para medir el ciclo
     hora. Eso significa que PWM solo está disponible en microcontroladores
     con al menos dos temporizadores adecuados. PWM usa el pin CCP2 (no CCP1)
     en chips PIC16 y OC1B (no OC1A) en AVR.

    Actualizado: LDmicro v4.x.x permite todo el hardware PWM.
    Ver https://github.com/LDmicro/LDmicro/wiki/LDmicro-PWM

    Puede establecer otra frecuencia base de PWM solo después de activar RESET PWM.
     Ver RESET PWM arriba.


> HACER PERSISTENTE          saved_var
                           --{PERSIST}--

    Cuando la condición de entrada de esta instrucción es verdadera, causa la
     La variable entera especificada se guardará automáticamente en EEPROM. Ese
     significa que su valor persistirá, incluso cuando el micro pierde
     poder. No hay necesidad de guardar explícitamente la variable en EEPROM;
     eso sucederá automáticamente, siempre que cambie la variable.
     La variable se carga automáticamente desde EEPROM después del reinicio de encendido. Si
     una variable que cambia con frecuencia se hace persistente, luego en
     La EEPROM en su micro puede desgastarse muy rápidamente, porque eso no es
     bueno para un número limitado (~ 100 000) de escrituras. Cuando el peldaño
     la condición es falsa, no pasa nada. Esta instrucción debe ser la
     instrucción más a la derecha en su peldaño.

    Ver https://github.com/LDmicro/LDmicro/wiki/MAKE-PERSISTENT-operation


> UART (SERIE) RECIBIR           var
                           --{UART RECV}--

    LDmicro puede generar código para usar el UART integrado en ciertos
     microcontroladores. En AVR con múltiples UART solo UART1 (no
     UART0) es compatible. Configure la velocidad en baudios usando Configuración -> MCU
     Parámetros Ciertas velocidades de transmisión pueden no ser alcanzables con ciertas
     frecuencias de cristal; LDmicro te avisará si este es el caso.

    Si la condición de entrada a esta instrucción es falsa, entonces nada
     sucede Si la condición de entrada es verdadera, esta instrucción intenta
     recibir un solo caracter de la UART. Si no se lee ningún caracter
     entonces la condición de salida es falsa. Si se lee un personaje, entonces su
     El valor ASCII se almacena en `var ', y la condición de salida es verdadera
     para un solo ciclo de PLC.


> UART (SERIE) ENVÍO             var
                           --{UART SEND}--

    LDmicro puede generar código para usar los UART integrados en ciertos
     microcontroladores. En AVRS con múltiples UART solo UART1 (no
     UART0) es compatible. Configure la velocidad en baudios usando Configuración -> MCU
     Parámetros Ciertas velocidades de transmisión pueden no ser alcanzables con ciertas
     frecuencias de cristal; LDmicro te avisará si este es el caso.

    Si la condición de entrada a esta instrucción es falsa, entonces nada
     sucede Si la condición de entrada es verdadera, entonces esta instrucción escribe
     un solo caracter para el UART. El valor ASCII del personaje a
     send debe haberse almacenado previamente en 'var'. La condición de salida
     del peldaño es verdadero si el UART está ocupado (actualmente transmitiendo un
     carácter), y falso de lo contrario.

    Recuerda que los caracteres tardan un poco en transmitirse. Hay varios
     formas de organizar la transmisión:
    1) Use el tiempo de ciclo del PLC, que es conscientemente mayor que el tiempo de transmisión UART.
   ||                                                               ||
   || ; El tiempo de ciclo del PLC es de 10 ms.                     ||
   || ; La velocidad de transmisión UART es de 9600 bps.            ||
   ||                                                               ||
   || ; En este caso, hay una reserva de tiempo diez veces mayor.   ||
   || ; La secuencia de caracteres se transmitirá sin pérdida.      ||
   ||                                                               ||
   || ; 1 2 3 4 5 6 7 8 9 10 11 12 ...                              ||
   ||                                                               ||
   ||                                              {ADD     char:=} ||
   ||----------------------------------------------{char    +    1}-||
   ||                                                               ||
   ||      char                                                     ||
   ||---{UART SEND}---                                              ||
   ||                                                               ||

    2) Use temporizadores para insertar retrasos entre caracteres. El retraso del temporizador debe ser
     más largo que el tiempo de transmisión UART.
   ||                                                                    ||
   || ; El tiempo de ciclo del PLC es de 1 ms.                           ||
   || ; La velocidad de transmisión UART es de 9600 bps.                 ||
   ||                                                                    ||
   || ; En este caso, hay una reserva de cinco veces.                    ||
   || ; La secuencia de caracteres se transmitirá sin pérdida.           ||
   ||                                                                    ||
   || ; char1 char2 char3   char1 char2 char3   char1 char2 char3   ...  ||
   || ; 1     5     10      2     10    20      3     15    30      ...  ||
   ||                                                                    ||
   ||       T0                                               Rstart      ||
   ||---[TCY 15 ms]--------------------------------------------( )-------||
   ||                                                                    ||
   ||                                                                    ||
   ||     Rstart             T1             _     _     {ADD    char1:=} ||
   ||-------] [----------[RTO 5 ms]------[_/ OSR_/ \_]-+{char1    +   1}-||
   ||                                                  |                 ||
   ||                                                  |      char1      ||
   ||                                                  +---{UART SEND}---||
   ||                                                                    ||
   ||                                                                    ||
   ||     Rstart             T2             _     _     {ADD    char2:=} ||
   ||-------] [----------[RTO 10 ms]-----[_/ OSR_/ \_]-+{char2    +   5}-||
   ||                                                  |                 ||
   ||                                                  |      char2      ||
   ||                                                  +---{UART SEND}---||
   ||                                                                    ||
   ||                                                                    ||
   ||     Rstart             T3             _     _     {ADD    char3:=} ||
   ||-------] [----------[RTO 15 ms]-----[_/ OSR_/ \_]-+{char3   +   10}-||
   ||                                                  |                 ||
   ||                                                  |      char3      ||
   ||                                                  +---{UART SEND}---||
   ||                                                  |                 ||
   ||                                                  |       T1        ||
   ||                                                  +------{RES}------||
   ||                                                  |                 ||
   ||                                                  |       T2        ||
   ||                                                  +------{RES}------||
   ||                                                  |                 ||
   ||                                                  |       T3        ||
   ||                                                  +------{RES}------||
   ||                                                                    ||

    3) Verifique la condición de salida de esta instrucción para asegurarse de que
     el carácter anterior se ha transmitido antes de intentar enviar un siguiente
     Caracter. Solo debe hacer que la condición de entrada sea verdadera (intente enviar
     un carácter) cuando la condición de salida es falsa (UART no está ocupado).
   ||                                                            ||
   || ; El tiempo de ciclo del PLC y la velocidad de             ||
   || ; transmisión UART son independientesy puede ser diferente ||
   ||                                                            ||
   || ; 1 2 3 4 5 6 7 8 9 10 11 12 ...                           ||
   ||                                                            ||
   ||      Rbusy                                {ADD     DATA:=} ||
   ||-------]/[------+--[_/ OSR_/ \_]-----------{DATA    +    1}-||
   ||                |                                           ||
   ||                |      DATA                      Rbusy      ||
   ||                +---{UART SEND}-------------------( )-------||
   ||                                                      ||


   ||                                                                       ||
   || ; DATA1 DATA2   DATA1 DATA2   DATA1 DATA2   ...                       ||
   || ; 1     10      2     20      3     30      ...                       ||
   ||                                                                       ||
   ||   Rbusy        DATA1       _       _        DATA2          Rbusy      ||
   ||----]/[--+---{UART SEND}---[ \_OSF_/ \_]--{UART SEND}--------( )-------||
   ||         |                                                             ||
   ||         |     _     _                                {ADD    DATA1:=} ||
   ||         +--[_/ OSR_/ \_]-+---------------------------{DATA1    +   1}-||
   ||                          |                                            ||
   ||                          |                           {ADD    DATA2:=} ||
   ||                          +---------------------------{DATA2   +   10}-||
   ||                                                                       ||

    4) Use el mensaje 'UART SEND: ¿está listo?' instrucción antes de UART ENVIAR a los cheque
     El estado UART.
   ||                                                    ||
   || ; 0 1 2 3 4 5 6 7 8 9 10 11 12 ...                 ||
   ||                                                    ||
   ||    Is ready?          DATA                         ||
   ||---[UART SEND]--+---{UART SEND}---------------------||
   ||                |                                   ||
   ||                |                  {ADD     DATA:=} ||
   ||                +------------------{DATA    +    1}-||
   ||                                                    ||
    Ver: UART communication FAQ
    https://github.com/LDmicro/LDmicro/wiki/UART-communication-FAQ

    Actualizado: las instrucciones UART RECEIVE, UART SEND pueden recibir / enviar más
     que las variables de longitud de un byte. Parámetro "Número de bytes a transmitir:"
     debe ser menor o igual al tamaño de la variable utilizada. El valor de 1 byte es
     compatible con la versión anterior de LDmicro.
     El parámetro "Esperar hasta que se transmitan todos los bytes:" controla el algoritmo
     de la transmisión: si 1 - todos los bytes se transmiten en un paquete,
     si 0: un byte por ciclo de PLC. Cuando todos los bytes se han transmitido,
     la condición de salida es "verdadera" durante un ciclo de PLC. El valor 0 es
     compatible con la versión anterior de LDmicro.
     Consulte: Preguntas frecuentes sobre comunicación UART, parte 2
    https://github.com/LDmicro/LDmicro/wiki/UART-communication-FAQ-part-2

    Investigue la instrucción de cadena formateada (siguiente) antes de usar esto
     instrucción. La instrucción de cadena formateada es mucho más fácil de usar,
     y es casi seguro que es capaz de hacer lo que quieras.

    Vea https://github.com/LDmicro/LDmicro/wiki/HOW-TO:-Look-Up-Table,-UART-SEND


> ENVÍO UART (SERIE)             var
                           --{UART SENDn}--

    Si la condición de entrada a esta instrucción es falsa, entonces nada
     sucede Si la condición de entrada es verdadera, entonces esta instrucción escribe
     una variable a la UART en formato binario sin formato. Un byte envía por ciclo
     de PLC, como el elemento 'FORMATO STR OVER UART'. La condición de salida
     del peldaño es verdadero si el UART está ocupado (actualmente transmitiendo un
     variable), y falso de lo contrario.


> ENVÍO UART: está listo ?     Is ready?
                           --[UART SEND]--

    Si la condición de entrada a esta instrucción es falsa, entonces nada
     sucede Si la condición de entrada es verdadera, entonces la salida es verdadera
     cuando el búfer de transmisión está vacío y listo para cargar nuevos datos,
     y falso de lo contrario.


> UART RECV: está disponible?    Is avail?
                              --[UART RECV]--

    Si la condición de entrada a esta instrucción es falsa, entonces nada
     sucede Si la condición de entrada es verdadera, la salida es verdadera cuando
     hay datos no leídos en el búfer de recepción y falsos de lo contrario.


> CADENA FORMATEADA SOBRE UART             var
                                   -{"Pressure: \3\r\n"}-

    LDmicro puede generar código para usar los UART integrados en ciertos
     microcontroladores. En AVRS con múltiples UART solo UART1 (no
     UART0) es compatible. Configure la velocidad en baudios usando Configuración -> MCU
     Parámetros Ciertas velocidades de transmisión pueden no ser alcanzables con ciertas
     frecuencias de cristal; LDmicro te avisará si este es el caso.

    Cuando la condición de entrada para esta instrucción pasa de falso a
     Es cierto, comienza a enviar una cadena completa a través del puerto serie. Si
     la cadena contiene la secuencia especial `\ 3 ', entonces esa secuencia
     será reemplazado con el valor de 'var', que es automáticamente
     convertido en una cadena. La variable se formateará para tomar
     exactamente 3 caracteres; por ejemplo, si 'var' es igual a 35, entonces
     la cadena exacta impresa será 'Presión: 35 \ r \ n' (tenga en cuenta el extra
     espacio). Si, en cambio, 'var' fuera igual a 1432, entonces el comportamiento sería
     ser indefinido, porque 1432 tiene más de tres dígitos. En ese caso
     sería necesario usar `\ 4 'en su lugar.

    Si la variable puede ser negativa, use `\ -3d '(o` \ -4d'
     etc.) en su lugar. Eso hará que LDmicro imprima un espacio líder para
     números positivos y un signo menos inicial para números negativos.

    Si se activan varias instrucciones de cadena formateadas a la vez
     (o si uno se energiza antes de que otro complete), o si estos
     las instrucciones se entremezclan con las instrucciones UART TX, luego el
     El comportamiento es indefinido.

    También es posible usar esta instrucción para generar una cadena fija,
     sin interpolar el valor de una variable entera en el texto que
     se envía por serie. En ese caso, simplemente no incluya el especial
     secuencia de escape.

    La condición de salida de esta instrucción es verdadera mientras es
     transmisión de datos, de lo contrario falso. Esta instrucción consume un muy
     gran cantidad de memoria de programa, por lo que debe usarse con moderación. los
     La implementación actual no es eficiente, pero una mejor será
     requieren modificaciones a todos los back-end.

   Use `\\'para una barra invertida literal. Además de la secuencia de escape
     para interpolar una variable entera, el siguiente control
     los caracteres están disponibles:

         Escape       Hex         Carácter
         Secuencia    Valor       Representado

         \a          0x07        BEL, alerta (pitido, campana)
         \b          0x08        BS, Retroceso (Escape)
         \e          0x1B        carácter de escape
         \f          0x0C        FF, Formfeed
         \n          0x0A        NL,Nueva línea (avance de línea)
         \r          0x0D        CR, Retorno de carro
         \t          0x09        HT, TAB, Pestaña horizontal
         \v          0x0B        VT, Pestaña vertical
         \'          0x27        Comillas simples
         \"          0x22        Comillas dobles
         \?          0x3F        Signo de interrogación
         \\          0x5C        Barra invertida
         \xhh        any         El byte cuyo valor numérico viene dado por
                                 hh: interpretado como un número hexadecimal
                                 del rango 0x00..0xFF (hex), 0..255 (dec)
         por ejemplo
          \xAB es un carácter con valor ASCII 0xAB (hexadecimal)

      Vea https://en.m.wikipedia.org/wiki/Escape_sequences_in_C

    ------------------------------ Códigos de control ASCII -------------------------------------
    |Dec Hex Ctl  Nombre Significado del control      |Dec Hex Ctl  Nombre  Significado de Control
    |--- --- ---  ---- ---------------------------  |--- --- ---  ---- -------------------------------
    |  0  00  ^@  NUL  nulo (cadena final)          | 16  10  ^P  DLE   escape de línea de datos
    |  1  01  ^A  SOH  inicio de encabezamiento     | 17  11  ^Q  DC1   dev ctrl 1 (X-ON)
    |  2  02  ^B  STX  inicio de texto              | 18  12  ^R  DC2   Ctrl 2 del dispositivo
    |  3  03  ^C  ETX  fin del texto                | 19  13  ^S  DC3   dev  ctrl 3 (X-OFF)
    |  4  04  ^D  EOT  fin de la transmisión        | 20  14  ^T  DC4   Ctrl 4 del dispositivo
    |  5  05  ^E  ENQ  petición                     | 21  15  ^U  NAK   reconocimiento negativo
    |  6  06  ^F  ACK  reconocer                    | 22  16  ^V  SYN   inactivo síncrono
    |  7  07  ^G  BEL  campana                \a    | 23  17  ^W  ETB   bloque de transmisión final
    |  8  08  ^H  BS   retroceso              \b    | 24  18  ^X  CAN   cancelar
    |  9  09  ^I  HT   Pestaña horizontal TAB \t    | 25  19  ^Y  EM    fin del medio
    | 10  0a  ^J  LF   linea de alimentación  \n    | 26  1a  ^Z  SUB   sustituir
    | 11  0b  ^K  VT   pestaña vertical       \v    | 27  1b  ^[  ESC   escape (Salir)
    | 12  0c  ^L  FF   alimentación de formulario \ | 28  1c  ^\  FS    separador de archivos
    | 13  0d  ^M  CR   retorno de carro   \r        | 29  1d  ^]  GS    separador de grupo
    | 14  0e  ^N  SO   desplazar fuera              | 30  1e  ^^  RS    separador de registros
    | 15  0f  ^O  SI   desplazar dentro             | 31  1f  ^_  US    separador de unidad


> SPI ENVIAR / RECIBIR          {SPI       SPI}
                               -{->recv send->}-

    Las funciones SPI solo están disponibles en el modo 'C', es decir, mediante la compilación de C,
     solo para ARM de 32 bits y AVR de tipo AtMega. Solo se puede usar un SPI
     en una misma escalera, llamada SPI, o SPI1, SPI2, SPI3 cuando hay varios
     disponible en el micro. SPI funciona solo en modo maestro, 8 bits de datos, con
     MSB primero, y su frecuencia se establece en el panel de configuración del micro
     en ldmicro. El pin SS se maneja para AVR pero no para ARM. Uno puede usar externo
     pines para activar / desactivar los esclavos en el bus SPI, y / o pin SS.
     En un SPI, el envío y la recepción son simultáneos, es por eso que ambas operaciones
     se combinan en una sola función.


> SPI ESCRIBIR                  {SPI_WR     SPI}
                               -{   "Message"->}-

    La función Escribir SPI envía una cadena a través de SPI, sin importar los datos entrantes.
     La cadena puede contener caracteres especiales introducidos por \\. No abuses de esto
     función, porque SPI puede ralentizar el programa y generar tiempos de ciclo
     problemas!

    NÓTESE BIEN:
    Las funciones SPI utilizan bibliotecas C externas (suministradas) que deben compilarse
     con el programa C principal generado por ldmicro al compilar a través de menús ldmicro
     <Compilar Atmel AVR-GCC> o <Compilar ARM-GCC>, seguido de un <FlashMCU>
     comando para construir el ejecutable .hex y, si está bien configurado, cargarlo
     ejecutable en el objetivo AVR o ARM.


> I2C LEER                      {I2C_RD    I2C}
                               -{->recv 0x20 0}-

    Las funciones I2C solo están disponibles en el modo 'C', es decir, mediante la compilación de C,
     solo para ARM de 32 bits y AVR de tipo AtMega. Solo se puede usar un bus I2C
     en una misma escalera, llamada I2C, o I2C1, I2C2, I2C3 cuando hay varios
     disponible en el micro. I2C funciona solo en modo maestro y puede acceder a cualquier
     registrarse (basado en 0) en cualquier dirección (1-127) en el bus I2C.
     La frecuencia I2C se configura en el panel de configuración del micro.
     La función I2C READ lee un byte en un registro en el esclavo en la dirección dada.


> I2C ESCRIBIR                  {I2C_WR    I2C}
                               -{0x20 0 send->}-

   La función I2C WRITE escribe un byte en un registro en el esclavo en la dirección dada.

    NÓTESE BIEN:
    Las funciones I2C utilizan bibliotecas C externas (suministradas) que deben compilarse
     con el programa C principal generado por ldmicro al compilar a través de menús ldmicro
     <Compilar Atmel AVR-GCC> o <Compilar ARM-GCC>, seguido de un <FlashMCU>
     comando para construir el ejecutable .hex y, si está bien configurado, cargarlo
     ejecutable en el objetivo AVR o ARM.


> CADENA FORMATEADA                         dest
                                       -{"string", var}-

    Para objetivos como Netzer con implementaciones de printf ya presentes
     Esta instrucción puede ser utilizada.

    Cuando la condición de entrada para esta instrucción pasa de falso a
     Es cierto, comienza a procesar la cadena con printf y escribe el resultado
     al registro de destino dado.

   Incrusta completamente la cadena dada en la imagen resultante.

    La variable dada puede ser cualquier registro del programa. Es
     utilizado como marcador de posición para imprimirf. La función printf accede
     el registro si se encuentra algún marcador de posición de estilo printf (es decir,% d).

    Dest es un registro donde se escribe el resultado. Esto debería
     ser la entrada superior de una memoria intermedia o circular.

    La condición de llamada de esta instrucción es siempre cierta.


> CLRWDT
                           --{CLRWDT}--

    Cuando la condición de entrada de esta instrucción es verdadera, causa la
     borrar el temporizador WDT. LDmicro ejecuta el comando CLRWDT en cada ciclo del PLC
     automáticamente (al comienzo del ciclo), por lo que necesita CLRWDT adicional
     si el período de ciclo del PLC es mayor que el período WDT si WDT está habilitado
     Esta instrucción debe ser la instrucción más a la derecha en su peldaño.


> LOCK (BLOQUEAR)
                           --{LOCK}--

    Cuando la condición de entrada de esta instrucción es verdadera, causa la
     Comando LOCK. Es un artificial
     situación para provocar el reinicio de WDT (si WDT está habilitado). Comando LOCK
     diseñado como bucle infinito. Es punto muerto, forma de congelar, bloquear el
     programa.
     El comando LOCK ejecuta goto a la dirección actual, es decir
     labelN: goto labelN (label02: rjmp label02), es decir, bucle infinito.
     El comando LOCK ejecuta el bucle infinito, pero WDT puede restablecer la MCU.
     Solo WDT o reinicio externo pueden descongelar el programa después del comando LOCK.


> SLEEP (DORMIR)
                           --{SLEEP}--

    Cuando la condición de entrada de esta instrucción es verdadera,
     se configura el modo SLEEP (apagado). Se utiliza para ahorrar energía.
     en suministro de batería.
     PIC: Despertar desde el sueño debido a una interrupción externa en el borde ascendente del pin RB0 / INT.
     PIC10xxxx: Despertar desde el modo de suspensión en el cambio de pin GP0, GP1, GP3.
     AVR: Despertar desde el sueño debido a una interrupción externa en el borde ascendente de los pines PD2 / INT0, PD3 / INT1.
     La operación SLEEP no afecta los pines MCU IO y otras operaciones LDmicro.
     Nota: SLEEP alarga el tiempo del ciclo del PLC y los temporizadores TON, TOF, RTO, CTY.
     Esto puede frustrar los planes, romper el flujo de trabajo.
     Esta instrucción debe ser la instrucción más correcta en su peldaño.


>LABEL, GOTO, SUBPROG, RETURN, ENDSUB, GOSUB

    LABEL y GOTO instrucciónes
    https://github.com/LDmicro/LDmicro/wiki/GOTO-instruction

    SUBPROG, RETURN, ENDSUB and GOSUB, LABEL y GOTO instrucciónes. Part 2
    https://github.com/LDmicro/LDmicro/wiki/SUBPROG,-RETURN,-ENDSUB-and-GOSUB,-LABEL-and-GOTO-instruction.-Part-2

    SUBPROG, RETURN, ENDSUB and GOSUB, LABEL y GOTO instrucciónes. Part 3
    https://github.com/LDmicro/LDmicro/wiki/SUBPROG,-RETURN,-ENDSUB-and-GOSUB,-LABEL-and-GOTO-instruction.-Part-3


> RAND                        Rand
                          --{ RAND }--

    El generador de números pseudoaleatorios devuelve el número en el rango completo
     de la variable 'Rand'.
     Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino 'Rand' con el siguiente número pseudoaleatorio calculado
     por un generador lineal congruencial (LCG). Cuando la entrada a esto
     la instrucción es falsa no pasa nada.
     Ver https://en.m.wikipedia.org/wiki/Linear_congruential_generator
     El generador está definido por la relación de recurrencia:
     X [n + 1] = (a * X [n] + c) mod m
     Constantes usadas de MTH $ RANDOM del VMS, versiones antiguas de glibc
     a = 69069 (0x10DCD)
     c = 1
     m = 2 ^ 32
     X = (X * 0x10DCD + 1)% 0x100000000
     RAND devuelve los bytes más significativos de X.
     X almacenado como $ seed_Rand variable de 32 bits.


> SRAND                     {SRAND     Rand}
                          --{$seed:=newSeed}--

    El generador de números pseudoaleatorios se inicializa utilizando el argumento
     pasado como nueva semilla. $ seed_Rand: = newSeed.
     Cuando la entrada a esta instrucción es verdadera, establece el valor dado
     variable de destino $ seed_Rand igual a la variable de origen dada o
     constante. Cuando la entrada a esta instrucción es falsa, nada
     sucede
     Dos inicializaciones diferentes con la misma semilla generarán la misma
     sucesión de resultados en llamadas posteriores a RAND.
     Si la semilla se establece en 1, el generador 'Rand' se reinicializa a su inicial
     valor y produce los mismos valores que antes de cualquier llamada a RAND o SRAND.
     Las fuentes de entropía pueden ser ADC, temporizadores, RAND anteriores guardados en EEPROM, etc.

     En este ejemplo tenemos dos SEPARAR los generadores de números pseudoaleatorios LCG.
     Pero si newSeed1 es igual a newSeed2, entonces RAnd1 y Rand2 son iguales
     Secuencias de números.
   ||     _    _      {SRAND     Rand1}                       ||
 1 ||--[_/ OSR/ \_]---{$seed:=newSeed1}-                      ||
   ||                                                         ||
   ||      Rand1                                              ||
 0 ||-----{RAND}------                                        ||
   ||                                                         ||
   ||                                                         ||
   ||     _    _      {SRAND     Rand2}                       ||
 0 ||--[_/ OSR/ \_]---{$seed:=newSeed2}-                      ||
   ||                                                         ||
   ||      Rand2                                              ||
 0 ||-----{RAND}------                                        ||
   ||                                                         ||


> 7-CONVERTIDOR DE SEGMENTOS   {7SEG    dest:=}
                             --{C          src}--

    La variable 'dest' obtiene el valor 'abcdefgDP', controla (resalta)
     los segmentos de fuente
     Puede usar la variable de puerto de acceso directo '#PORTx' como la variable 'dest'.
     Se puede conectar a los ánodos (cátodos) del módulo LED de 7 segmentos.
     a través de las resistencias limitantes de corriente.

     Para encender (resaltar) el segmento LED "a", se requiere un nivel alto
     en el pin "a" y un nivel bajo en el pin común, cuando un módulo con
     Se utiliza la conexión LED de cátodo común.
     Cuando se utiliza un módulo con la conexión de ánodo común, para encender
     el segmento LED "a", el nivel bajo se requiere en el pin "a" y
     Se requiere un alto nivel en el pin común. Utilice el parámetro 'A' en su lugar
     de la 'C' para especificar qué tipo de conexión común se utiliza.

     Fuente de visualización de 7 segmentos
         a
        --
     f|    |b
      |  g |
        --
     e|    |c
      |    |
        -- .
         d  DP

    SEGMENTOS    DP g f e d c b a
    'dest'  BIT   7 6 5 4 3 2 1 0
    DP - es un segmento de puntos


    a  --|>|-----+-- Conexión LED de cátodos común
                 |
    b  --|>|-----+
    ...          |
                 |
    DP --|>|-----+

    a  --|<|-----+-- Conexión LED de ánodos comunes
                 |
    b  --|<|-----+
    ...          |
                 |
    DP --|<|-----+


    La variable 'src' (char) debe estar en el rango de 0..128 y generalmente tiene un tamaño de 1 byte.
     Se implementan 128 caracteres de códigos de tabla ASCII.
     Los primeros 32 caracteres ASCII replased a los dígitos hexadecimales.
     El 129º símbolo es un símbolo de un grado 'o' para usar con un valor de temperatura.
DIRECCION=  0               16(0x10)       31(0x1F)
row+colmn  |               |              | de 0 a 15 - dígitos hexadecimales
  0       0123456789ABCDEF0123456789ABCDEF  del 16 al 31 - dígitos hexadecimales con el punto DP
 32(0x20)  !"#$%&'()*+,-./0123456789:;<=>?
 64(0x40) @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
 96(0x60) `abcdefghijklmnopqrstuvwxyz{|}~
128(0x80) o
          ^
          |_ grado char 0xB0

    ' ' - cpace char 0x20 - en blanco
    DEL char 0x7F - en blanco

   Ver pantalla LED de segmento X, ejemplo de fuente
    https://github.com/LDmicro/LDmicro/wiki/X-segment-LED-display,-font-example


> 9-CONVERTIDOR DE SEGMENTOS   {9SEG    dest:=}
                             --{C          src}--
         a
        ---j
     f|   / |b
      |  /  |
        ---g
     e|  /  |c
      | /   |
       m---
         d   DP

    SEGMENTO  0 0 m j DP g f e d c b a
    BIT           9 8  7 6 5 4 3 2 1 0
    nibbles  ^        ^       ^       ^
    El tamaño de la variable 'dest' debe ser de al menos 2 bytes.


> 14-CONVERTIDOR DE SEGMENTOS  {14SEG   dest:=}
                             --{C          src}--
         a
      h --- j
     f|\ |i/|b
      | \|/ |
     g1-- --g2
     e| /|\ |c
      |/ |l\|
      m --- k
         d   DP

    SEGMENTO 0 g2  l  k  i  h  m  j DP g1  f  e  d  c  b  a
    BIT        14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
    nibbles ^          ^           ^           ^           ^
    El tamaño de la variable 'dest' debe ser de al menos 2 bytes.


> 16-CONVERTIDOR DE SEGMENTOS  {16SEG   dest:=}
                             --{C          src}--
       a1 a2
      h-- --j
     f|\ |i/|b
      | \|/ |
     g1-- --g2
     e| /|\ |c
      |/ |l\|
      m-- --k
       d1 d2 DP

    SEGMENTO  0  0  0 a2 d2 g2  l  k  i  h  m  j DP g1  f  e d1  c  b a1
    BIT               16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
    nibbles  ^          ^           ^           ^           ^           ^
    El tamaño de la variable 'dest' debe ser de al menos 3 bytes.


> CONVERTIR BINARIO EN BCD    {BIN2BCD dest:=}
                            --{           src}-

    El 'src' es un valor binario con una longitud de 1,2,3,4 bytes.
     El 'dest' es un valor BCD desempaquetado con 3, 5, 8, 10 bytes de longitud.
     Desempaquetado: cada número está codificado en un byte, con cuatro bits
     representando el número y los bits restantes que no tienen significado.
     El decimal 99 (0x63) se convertirá al valor 0x00 09 09.
     El decimal 100 (0x64) se convertirá al valor 0x01 00 00.
     Ver https://en.wikipedia.org/wiki/Binary-coded_decimal


> CODIFICADOR DE CUADRATURA   ~~[XqA0 XqB0            YqDir0]-
                              -\[XqZ0   QUAD ENCOD   qCount0]^-

    La instrucción QUADRATURE ENCODER toma dos señales codificadas en cuadratura
     (A y B) de un dispositivo codificador incremental rotativo o lineal.
     Ver https://en.wikipedia.org/wiki/Incremental_encoder

 Nivel
 Logico             move (mover) ->             |            <- move (mover)
         ^
         | ___         _______         ___________          _______         ___
Entrada A|    |_______|       |_______|           |________|       |_______|
         |
         | _______         _______         ___         ________         _______
Entrada B|        |_______|       |_______|   |_______|        |_______|
         |
         |
Contador |  0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 3 |   | 2 |   | 1 |   | 0
         |
 Salida  | ___________________________________   disminuir o CCW o hacia atrás
 Direcion|    aumentar o CW o hacia adelante  |________________________________
         |
 Salida  |
  Pulso  | _______^_______^_______^_______^_______^_______^_______^_______^____
         |
       --+----------------------------------------------------------------> Tiempo
         |
           '^' - es un impulso de tiempo de ciclo del PLC
    Sugerencia: use el pulso de salida para determinar si se cambió el contador,
     No para contar.

    La instrucción QUAD ENCOD puede contener 3 o 2 entradas y 1 o 0 salida.
     Las entradas A y B deben estar ubicadas en el mismo PUERTO MCU.
     Por ejemplo, RBx y RBx, no RAx, RBx.
     La entrada Z es opcional y puede estar vacía.
     La salida Dir es opcional y puede estar vacía.
     La salida Dir puede ser Y (pin) o R (relé interno).

   ||                                                                    ||
   ||       R0        ~~[XqA0 XqB0            YqDir0]-         R1        ||
   ||-------] [--------\[XqZ0   QUAD ENCOD   qCount0]^---------( )-------||
   ||                                                                    ||

    Cuando la condición R0 de entrada de la instrucción QUAD ENCOD es falsa,
     las entradas A, B, Z se ignoran.
     Cuando la condición R0 de entrada de la instrucción QUAD ENCOD es verdadera,
     los pulsos en las entradas A, B, Z se decodifican en el valor del contador,
     la señal de salida Dir es alta, cuando el contador aumenta y
     un nivel bajo cuando se disminuye el contador, se produce un pulso de salida R1.
     El valor del contador cambia cuando ambas entradas A y B cambian.
     Esto corresponde al multiplicador de reloj x2. La frecuencia de la salida
     pulsos es el doble de la frecuencia de los pulsos de entrada A (B).
     La frecuencia de los pulsos de entrada A (B) debe ser menor que la frecuencia de
     el ciclo PLC / 4, de lo contrario habrá pérdidas de pulsos de entrada.
     Un rebote de los pulsos de entrada A (B) debe ser menor que el tiempo de ciclo del PLC / 8.

    La entrada Z puede ser dinámica (activada por flanco) o estática.
     Si el parámetro 'Count per revol' es 0 y la entrada Z está activa, el contador se establece en 0.
     Si el parámetro 'Count per revol' es mayor que 0 y la entrada Z está activa, entonces
     el contador se redondeará a un múltiplo del valor 'Recuento por revolución'.
     Si el parámetro 'Count per revol' es menor que 0, entonces la entrada Z se ignora.


 Nivel
 Logico           (Mover)   move ->
         ^
         | ___         _______         _______         _______         ________
Entrada A|    |_______|       |_______|       |_______|       |_______|
         |
         | _______         _______         _______         _______         ____
Entrada B|        |_______|       |_______|       |_______|       |_______|
         |
         |
Entrada Z| _______________________________________________________/\___________
         |
         |
         |                                  'Count per revol' es 0 (restablecer el contador)
         |
Contador |  0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 5 |   | 6 |   | 0 |   | 1
         |
         |
         |  (hay pérdidas de pulsos A, B) 'Count per revol' es 10 (recupera el contador)
         |
Contador |  0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 5 |   | 6 |   |10 |   | 11
         |
       --+----------------------------------------------------------------> tiempo
         |

    Para simular las entradas A, B, Z: haga doble clic en el nombre de la entrada en la lista
     en la parte inferior de la pantalla.

    Ver para más detalles https://github.com/LDmicro/LDmicro/wiki/Incremental-QUADRATURE-ENCODER
    Incremental QUADRATURE ENCODER controls the brightness of the LED (PWM out)
    https://github.com/LDmicro/LDmicro/wiki/Incremental-QUADRATURE-ENCODER-controls-the-brightness-of-the-LED-(PWM-out)


UNA NOTA SOBRE EL USO DE LAS MATEMÁTICAS
========================================

Recuerde que LDmicro realiza solo matemáticas de enteros de 16 bits. Eso significa
que el resultado final de cualquier cálculo que realice debe ser un
entero entre -32768 y 32767. También significa que el intermedio
los resultados de su cálculo deben estar todos dentro de ese rango.

Por ejemplo, digamos que desea calcular y = (1 / x) * 1200,
donde x está entre 1 y 20. Entonces y va entre 1200 y 60, que
cabe en un número entero de 16 bits, por lo que al menos en teoría es posible
realiza el cálculo Hay dos formas de codificar esto:
puede realizar el recíproco y luego multiplicar:

   ||         {DIV  temp  :=}          ||
   ||---------{ 1 / x       }----------||
   ||                                  ||
   ||          {MUL  y  :=  }          ||
   ||----------{ temp * 1200}----------||
   ||                                  ||

O simplemente puede hacer la división directamente, en un solo paso:

   ||           {DIV  y  :=}           ||
   ||-----------{ 1200 / x }-----------||

Matemáticamente, estos dos son equivalentes; pero si los pruebas, entonces
encontrará que el primero da un resultado incorrecto de y = 0. Que
es porque la variable 'temp' se desborda. Por ejemplo, cuando x = 3,
(1 / x) = 0.333, pero eso no es un número entero; la operación de división
aproxima esto como temp = 0. Entonces y = temp * 1200 = 0. En el segundo
En caso de que no haya un resultado intermedio para el flujo inferior, todo funciona.

Si está viendo problemas con sus matemáticas, marque el intermedio
resultados de subdesbordamiento (o desbordamiento, que `se envuelve '; por ejemplo,
32767 + 1 = -32768). Cuando sea posible, elija unidades que pongan valores en
un rango de -100 a 100.

Cuando necesite escalar una variable por algún factor, hágalo usando una multiplicación
y una división Por ejemplo, para escalar y = 1.8 * x, calcule y = (9/5) * x
(que es lo mismo, ya que 1.8 = 9/5), y codifique esto como y = (9 * x) / 5,
realizando la multiplicación primero:

   ||         {MUL  temp  :=}          ||
   ||---------{ x * 9       }----------||
   ||                                  ||
   ||           {DIV  y  :=}           ||
   ||-----------{ temp / 5 }-----------||

This works for all x < (32767 / 9), or x < 3640. For larger values of x,
the variable `temp' would overflow. There is a similar lower limit on x.


ESTILO DE CODIFICACIÓN
======================

Permito múltiples bobinas en paralelo en un solo peldaño. Esto significa que
puedes hacer cosas como esta:

   ||       Xa               Ya        ||
 1 ||-------] [--------------( )-------||
   ||                                  ||
   ||       Xb               Yb        ||
   ||-------] [------+-------( )-------||
   ||                |                 ||
   ||                |       Yc        ||
   ||                +-------( )-------||
   ||                                  ||

En lugar de esto:

   ||       Xa               Ya        ||
 1 ||-------] [--------------( )-------||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||       Xb               Yb        ||
 2 ||-------] [--------------( )-------||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||       Xb               Yc        ||
 3 ||-------] [--------------( )-------||
   ||                                  ||

Esto significa que, en teoría, podría escribir cualquier programa como un peldaño gigante,
y no hay necesidad de usar varios peldaños en absoluto. En la práctica eso
sería una mala idea, porque a medida que los peldaños se vuelven más complejos se vuelven
más difícil de editar sin eliminar y volver a dibujar mucha lógica.

Aún así, a menudo es una buena idea agrupar la lógica relacionada como una sola
peldaño. Esto genera un código casi idéntico a si hiciste peldaños separados,
pero muestra que están relacionados cuando los miras en la escalera
diagrama.

                  *                 *                  *

En general, se considera una forma pobre de escribir código de tal manera que
su salida depende del orden de los peldaños. Por ejemplo, este código
no es muy bueno si tanto Xa como Xb podrían ser ciertos:

   ||       Xa         {v  :=       }  ||
 1 ||-------] [--------{ 12      MOV}--||
   ||                                  ||
   ||       Xb         {v  :=       }  ||
   ||-------] [--------{ 23      MOV}--||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||      [v >]             Yc        ||
 2 ||------[ 15]-------------( )-------||
   ||                                  ||

Romperé esta regla si al hacerlo puedo hacer un código
significativamente más compacto, sin embargo. Por ejemplo, así es como lo haría
Convierta una cantidad binaria de 4 bits en Xb3: 0 en un entero:

   ||                                   {v  :=       }  ||
 3 ||-----------------------------------{ 0       MOV}--||
   ||                                                   ||
   ||       Xb0                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 1    }-----------||
   ||                                                   ||
   ||       Xb1                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 2    }-----------||
   ||                                                   ||
   ||       Xb2                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 4    }-----------||
   ||                                                   ||
   ||       Xb3                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 8    }-----------||
   ||                                                   ||

Si la instrucción MOV se movió al final del peldaño en lugar de
arriba, entonces el valor de v cuando se lee en otra parte del programa
ser 0. La salida de este código, por lo tanto, depende del orden en que
Se evalúan las instrucciones. Considerando lo engorroso que sería
para codificar esto de otra manera, acepto eso.

ABREVIATURAS
============
PLC - controlador lógico programable.
PWM - modulación de ancho de pulso.
ADC - convertidor analógico a digital.
PCB - placa de circuito impreso

BUGS
====

LDmicro no genera código muy eficiente; es lento de ejecutar y
derrochador de flash y RAM. A pesar de esto, un PIC o AVR de tamaño mediano puede
hacer todo lo que puede hacer un PLC pequeño, por lo que esto no me molesta mucho.

La longitud máxima de los nombres de variables es muy limitada. Esto es para que
encajan bien en el diagrama de escalera, así que no veo una buena solución
a ese.

Si su programa es demasiado grande para la hora, memoria de programa o memoria de datos
restricciones del dispositivo que ha elegido, entonces probablemente no lo hará
obtener un error Simplemente se arruinará en alguna parte.

La programación descuidada en las rutinas de carga / guardado de archivos probablemente lo hace
posible bloquear o ejecutar código arbitrario dado un corrupto o malicioso
archivo .ld.

Informe errores adicionales o solicitudes de características al autor.

Gracias a:
    * Marcelo Solano, por informar de un error de interfaz de usuario en Win98
    * Serge V. Polubarjev, por no solo notar que RA3: 0 en el
      PIC16F628 no funcionó, pero también me dijo cómo solucionarlo
    * Maxim Ibragimov, para informar y diagnosticar problemas importantes
      con los objetivos ATmega16 y ATmega162 hasta entonces no probados
    * Bill Kishonti, por informar que el simulador se bloqueó cuando el
      programa de lógica de escalera dividido por cero
    * Mohamed Tayae, por informar que las variables persistentes se rompieron
      en el PIC16F628
    * David Rothwell, por informar de varios errores de interfaz de usuario y un
      problema con la función "Exportar como texto"

COPIA Y DESCARGO DE RESPONSABILIDAD
===================================

NO USE EL CÓDIGO GENERADO POR LDMICRO EN APLICACIONES DONDE SOFTWARE
LA FALLA PODRÍA RESULTAR EN PELIGRO PARA LA VIDA HUMANA O DAÑAR LA PROPIEDAD. EL
EL AUTOR NO ASUME NINGUNA RESPONSABILIDAD POR NINGÚN DAÑO RESULTANTE DE LA OPERACIÓN
DE LDMICRO O CÓDIGO GENERADO POR LDMICRO.

Este programa es software libre: puede redistribuirlo y / o modificarlo
bajo los términos de la Licencia Pública General GNU publicada por el
Free Software Foundation, ya sea la versión 3 de la Licencia, o (a su
opción) cualquier versión posterior.

Este programa se distribuye con la esperanza de que sea útil, pero
SIN NINGUNA GARANTÍA; sin siquiera la garantía implícita de COMERCIABILIDAD
o APTITUD PARA UN PROPÓSITO EN PARTICULAR. Ver la Licencia Pública General de GNU
para más detalles.

Debería haber recibido una copia de la Licencia Pública General de GNU junto con
con este programa Si no, ver <http://www.gnu.org/licenses/>.


Jonathan Westhues

Rijswijk      -- Dec 2004
Waterloo ON   -- Jun, Jul 2005
Cambridge MA  -- Sep, Dec 2005
                 Feb, Mar 2006
                 Feb 2007
Seattle WA    -- Feb 2009

Email: user jwesthues, at host cq.cx

Soporte LDmicro:
    Foro LDmicro:  http://cq.cx/ladder-forum.pl
    Último lanzamiento: https://github.com/LDmicro/LDmicro/releases
    Repositorio:     https://github.com/LDmicro/LDmicro
    Email:          LDmicro.GitHub@gmail.com
